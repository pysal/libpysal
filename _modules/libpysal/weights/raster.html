<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>libpysal.weights.raster &#8212; libpysal v4.14.1 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pysal-styles.css?v=38b0ce36" />
    <script src="../../../_static/documentation_options.js?v=2aa3d6d4"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          libpysal</a>
        <span class="navbar-text navbar-version pull-left"><b>4.14.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../user-guide/intro.html">User Guide</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-released-version">Installing released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-development-version">Installing development version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-graph">Spatial Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-weights">Spatial Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#cg-computational-geometry">cg: Computational Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#io">io</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#kernels">kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#examples">examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user-guide/intro.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/data/examples.html">Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/weights/intro.html">Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/graph/intro.html">Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/kernels.html">Kernels</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration.html">W to Graph Member Comparisions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-common-to-w-and-graph">Members common to W and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-common-to-w-and-graph-with-different-types">Members common to W and Graph with different types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-unique-to-w">Members unique to W</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-unique-to-graph">Members unique to Graph</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for libpysal.weights.raster</h1><div class="highlight"><pre>
<span></span><span class="c1"># ruff: noqa: B006, N802</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">lat2SW</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.weights</span><span class="w"> </span><span class="kn">import</span> <span class="n">WSP</span><span class="p">,</span> <span class="n">W</span>

<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pytest&quot;</span><span class="p">,</span> <span class="s2">&quot;py.test&quot;</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">jit</span><span class="p">(</span><span class="o">*</span><span class="n">dec_args</span><span class="p">,</span> <span class="o">**</span><span class="n">dec_kwargs</span><span class="p">):</span>  <span class="c1"># noqa: ARG001</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        decorator mimicking numba.jit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">intercepted_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">f_args</span><span class="p">,</span> <span class="o">**</span><span class="n">f_kwargs</span><span class="p">):</span>  <span class="c1"># noqa: ARG001</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">intercepted_function</span>

<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">..common</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;da2W&quot;</span><span class="p">,</span> <span class="s2">&quot;da2WSP&quot;</span><span class="p">,</span> <span class="s2">&quot;w2da&quot;</span><span class="p">,</span> <span class="s2">&quot;wsp2da&quot;</span><span class="p">,</span> <span class="s2">&quot;testDataArray&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="da2W">
<a class="viewcode-back" href="../../../generated/libpysal.weights.da2W.html#libpysal.weights.da2W">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">da2W</span><span class="p">(</span>
    <span class="n">da</span><span class="p">,</span>
    <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;queen&quot;</span><span class="p">,</span>
    <span class="n">z_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coords_labels</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">include_nodata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a W object from xarray.DataArray with an additional</span>
<span class="sd">    attribute index containing coordinate values of the raster</span>
<span class="sd">    in the form of Pandas.Index/MultiIndex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        Input 2D or 3D DataArray with shape=(z, y, x)</span>
<span class="sd">    criterion : {&quot;rook&quot;, &quot;queen&quot;}</span>
<span class="sd">        Type of contiguity. Default is queen.</span>
<span class="sd">    z_value : int/string/float</span>
<span class="sd">        Select the z_value of 3D DataArray with multiple layers.</span>
<span class="sd">    coords_labels : dictionary</span>
<span class="sd">        Pass dimension labels for coordinates and layers if they do not</span>
<span class="sd">        belong to default dimensions, which are (band/time, y/lat, x/lon)</span>
<span class="sd">        e.g. coords_labels = {&quot;y_label&quot;: &quot;latitude&quot;,</span>
<span class="sd">        &quot;x_label&quot;: &quot;longitude&quot;, &quot;z_label&quot;: &quot;year&quot;}</span>
<span class="sd">        Default is {} empty dictionary.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of contiguity, this will select all neighbors upto kth order.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">    include_nodata : boolean</span>
<span class="sd">        If True, missing values will be assumed as non-missing when</span>
<span class="sd">        selecting higher_order neighbors, Default is False</span>
<span class="sd">    n_jobs : int</span>
<span class="sd">        Number of cores to be used in the sparse weight construction. If -1,</span>
<span class="sd">        all available cores are used. Default is 1.</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        Optional arguments for :class:`libpysal.weights.W`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : libpysal.weights.W</span>
<span class="sd">       instance of spatial weights class W with an index attribute</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. Lower order contiguities are also selected.</span>
<span class="sd">    2. Returned object contains `index` attribute that includes a</span>
<span class="sd">       `Pandas.MultiIndex` object from the DataArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from libpysal.weights.raster import da2W, testDataArray</span>
<span class="sd">    &gt;&gt;&gt; da = testDataArray().rename(</span>
<span class="sd">            {&#39;band&#39;: &#39;layer&#39;, &#39;x&#39;: &#39;longitude&#39;, &#39;y&#39;: &#39;latitude&#39;})</span>
<span class="sd">    &gt;&gt;&gt; da.dims</span>
<span class="sd">    (&#39;layer&#39;, &#39;latitude&#39;, &#39;longitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; da.shape</span>
<span class="sd">    (3, 4, 4)</span>
<span class="sd">    &gt;&gt;&gt; da.coords</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        * layer      (layer) int64 1 2 3</span>
<span class="sd">        * latitude   (latitude) float64 90.0 30.0 -30.0 -90.0</span>
<span class="sd">        * longitude  (longitude) float64 -180.0 -60.0 60.0 180.0</span>
<span class="sd">    &gt;&gt;&gt; da.attrs</span>
<span class="sd">    {&#39;nodatavals&#39;: (-32768.0,)}</span>
<span class="sd">    &gt;&gt;&gt; coords_labels = {</span>
<span class="sd">        &quot;z_label&quot;: &quot;layer&quot;,</span>
<span class="sd">        &quot;y_label&quot;: &quot;latitude&quot;,</span>
<span class="sd">        &quot;x_label&quot;: &quot;longitude&quot;</span>
<span class="sd">    }</span>
<span class="sd">    &gt;&gt;&gt; w = da2W(da, z_value=2, coords_labels=coords_labels)</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%w.pct_nonzero</span>
<span class="sd">    &#39;30.000&#39;</span>
<span class="sd">    &gt;&gt;&gt; w[(2, 90.0, 180.0)] == {(2, 90.0, 60.0): 1, (2, 30.0, 180.0): 1}</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; len(w.index)</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; w.index[:2]</span>
<span class="sd">    MultiIndex([(2, 90.0,  60.0),</span>
<span class="sd">                (2, 90.0, 180.0)],</span>
<span class="sd">               names=[&#39;layer&#39;, &#39;latitude&#39;, &#39;longitude&#39;])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`libpysal.weights.weights.W`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;You are trying to build a full W object from &quot;</span>
        <span class="s2">&quot;xarray.DataArray (raster) object. This computation &quot;</span>
        <span class="s2">&quot;can be very slow and not scale well. It is recommended, &quot;</span>
        <span class="s2">&quot;if possible, to instead build WSP object, which is more &quot;</span>
        <span class="s2">&quot;efficient and faster. You can do this by using da2WSP method.&quot;</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">wsp</span> <span class="o">=</span> <span class="n">da2WSP</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">z_value</span><span class="p">,</span> <span class="n">coords_labels</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">include_nodata</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">wsp</span><span class="o">.</span><span class="n">to_W</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># temp addition of index attribute</span>
    <span class="n">w</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">wsp</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">w</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">get_nodata</span><span class="p">(</span><span class="n">da</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify nodata value in a `DataArray`</span>

<span class="sd">    NOTE: follows guidance from https://corteva.github.io/rioxarray/stable/getting_started/nodata_management.html</span>
<span class="sd">    ...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        Input 2D or 3D DataArray with shape=(z, y, x)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nodata : int/float</span>
<span class="sd">        Value used for nodata pixels. If no value is available, `None` is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="s2">&quot;rio&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">nodata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodata_from_attrs</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">nodata_from_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify nodata value in a `DataArray.attrs`</span>

<span class="sd">    NOTE: follows guidance from https://corteva.github.io/rioxarray/stable/getting_started/nodata_management.html</span>
<span class="sd">    ...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    attrs : dict</span>
<span class="sd">           `DataArray.attrs` dictionary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nodata : int/float</span>
<span class="sd">        Value used for nodata pixels. If no value is available, `None` is returned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">,</span> <span class="s2">&quot;missing_value&quot;</span><span class="p">,</span> <span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="s2">&quot;nodata&quot;</span><span class="p">,</span> <span class="s2">&quot;nodatavals&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="da2WSP">
<a class="viewcode-back" href="../../../generated/libpysal.weights.da2WSP.html#libpysal.weights.da2WSP">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">da2WSP</span><span class="p">(</span>
    <span class="n">da</span><span class="p">,</span>
    <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;queen&quot;</span><span class="p">,</span>
    <span class="n">z_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coords_labels</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">include_nodata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a WSP object from xarray.DataArray with an additional</span>
<span class="sd">    attribute index containing coordinate values of the raster</span>
<span class="sd">    in the form of Pandas.Index/MultiIndex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        Input 2D or 3D DataArray with shape=(z, y, x)</span>
<span class="sd">    criterion : {&quot;rook&quot;, &quot;queen&quot;}</span>
<span class="sd">        Type of contiguity. Default is queen.</span>
<span class="sd">    z_value : int/string/float</span>
<span class="sd">        Select the z_value of 3D DataArray with multiple layers.</span>
<span class="sd">    coords_labels : dictionary</span>
<span class="sd">        Pass dimension labels for coordinates and layers if they do not</span>
<span class="sd">        belong to default dimensions, which are (band/time, y/lat, x/lon)</span>
<span class="sd">        e.g. coords_labels = {&quot;y_label&quot;: &quot;latitude&quot;,</span>
<span class="sd">        &quot;x_label&quot;: &quot;longitude&quot;, &quot;z_label&quot;: &quot;year&quot;}</span>
<span class="sd">        Default is {} empty dictionary.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of contiguity, this will select all neighbors upto kth order.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">    include_nodata : boolean</span>
<span class="sd">        If True, missing values will be assumed as non-missing when</span>
<span class="sd">        selecting higher_order neighbors, Default is False</span>
<span class="sd">    n_jobs : int</span>
<span class="sd">        Number of cores to be used in the sparse weight construction. If -1,</span>
<span class="sd">        all available cores are used. Default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wsp : libpysal.weights.WSP</span>
<span class="sd">       instance of spatial weights class WSP with an index attribute</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. Lower order contiguities are also selected.</span>
<span class="sd">    2. Returned object contains `index` attribute that includes a</span>
<span class="sd">       `Pandas.MultiIndex` object from the DataArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from libpysal.weights.raster import da2WSP, testDataArray</span>
<span class="sd">    &gt;&gt;&gt; da = testDataArray().rename(</span>
<span class="sd">            {&#39;band&#39;: &#39;layer&#39;, &#39;x&#39;: &#39;longitude&#39;, &#39;y&#39;: &#39;latitude&#39;})</span>
<span class="sd">    &gt;&gt;&gt; da.dims</span>
<span class="sd">    (&#39;layer&#39;, &#39;latitude&#39;, &#39;longitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; da.shape</span>
<span class="sd">    (3, 4, 4)</span>
<span class="sd">    &gt;&gt;&gt; da.coords</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        * layer      (layer) int64 1 2 3</span>
<span class="sd">        * latitude   (latitude) float64 90.0 30.0 -30.0 -90.0</span>
<span class="sd">        * longitude  (longitude) float64 -180.0 -60.0 60.0 180.0</span>
<span class="sd">    &gt;&gt;&gt; da.attrs</span>
<span class="sd">    {&#39;nodatavals&#39;: (-32768.0,)}</span>
<span class="sd">    &gt;&gt;&gt; coords_labels = {</span>
<span class="sd">        &quot;z_label&quot;: &quot;layer&quot;,</span>
<span class="sd">        &quot;y_label&quot;: &quot;latitude&quot;,</span>
<span class="sd">        &quot;x_label&quot;: &quot;longitude&quot;</span>
<span class="sd">    }</span>
<span class="sd">    &gt;&gt;&gt; wsp = da2WSP(da, z_value=2, coords_labels=coords_labels)</span>
<span class="sd">    &gt;&gt;&gt; wsp.n</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; pct_sp = wsp.sparse.nnz *1. / wsp.n**2</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.3f&quot;%pct_sp</span>
<span class="sd">    &#39;0.300&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(wsp.sparse[4].todense())</span>
<span class="sd">    [[0 0 1 0 0 1 1 1 0 0]]</span>
<span class="sd">    &gt;&gt;&gt; wsp.index[:2]</span>
<span class="sd">    MultiIndex([(2, 90.0,  60.0),</span>
<span class="sd">                (2, 90.0, 180.0)],</span>
<span class="sd">               names=[&#39;layer&#39;, &#39;latitude&#39;, &#39;longitude&#39;])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`libpysal.weights.weights.WSP`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span>  <span class="c1"># noqa: F401</span>

        <span class="n">use_numba</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;numba cannot be imported, parallel processing &quot;</span>
            <span class="s2">&quot;and include_nodata functionality will be disabled. &quot;</span>
            <span class="s2">&quot;falling back to slower method&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">use_numba</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">include_nodata</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
        <span class="n">sw_tup</span><span class="p">,</span> <span class="n">ser</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_da2wsp</span><span class="p">(</span>
            <span class="n">da</span><span class="p">,</span>
            <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
            <span class="n">z_value</span><span class="o">=</span><span class="n">z_value</span><span class="p">,</span>
            <span class="n">coords_labels</span><span class="o">=</span><span class="n">coords_labels</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">include_nodata</span><span class="o">=</span><span class="n">include_nodata</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">use_numba</span><span class="o">=</span><span class="n">use_numba</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">sw</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
            <span class="n">sw_tup</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sw</span><span class="p">,</span> <span class="n">ser</span> <span class="o">=</span> <span class="n">_da2wsp</span><span class="p">(</span>
            <span class="n">da</span><span class="p">,</span>
            <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
            <span class="n">z_value</span><span class="o">=</span><span class="n">z_value</span><span class="p">,</span>
            <span class="n">coords_labels</span><span class="o">=</span><span class="n">coords_labels</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">include_nodata</span><span class="o">=</span><span class="n">include_nodata</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">use_numba</span><span class="o">=</span><span class="n">use_numba</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Higher_order functionality, this uses idea from</span>
    <span class="c1"># libpysal#313 for adding higher order neighbors.</span>
    <span class="c1"># Since diagonal elements are also added in the result,</span>
    <span class="c1"># this method set the diagonal elements to zero and</span>
    <span class="c1"># then eliminate zeros from the data. This changes the</span>
    <span class="c1"># sparsity of the csr_matrix !!</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_nodata</span><span class="p">:</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">sw</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sw</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="n">sw</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">sw</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">index</span>
    <span class="n">wsp</span> <span class="o">=</span> <span class="n">WSP</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wsp</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_da2wsp</span><span class="p">(</span>
    <span class="n">da</span><span class="p">,</span>
    <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;queen&quot;</span><span class="p">,</span>
    <span class="n">z_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coords_labels</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">include_nodata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">use_numba</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for da2WSP that can be reused in Graph&quot;&quot;&quot;</span>
    <span class="n">z_id</span><span class="p">,</span> <span class="n">coords_labels</span> <span class="o">=</span> <span class="n">_da_checker</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">z_value</span><span class="p">,</span> <span class="n">coords_labels</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">z_id</span><span class="p">:</span>
        <span class="n">slice_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">slice_dict</span><span class="p">[</span><span class="n">coords_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">slice_dict</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">slice_dict</span><span class="p">[</span><span class="n">coords_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">z_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_id</span><span class="p">)</span>
        <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="p">[</span><span class="n">slice_dict</span><span class="p">]</span>

    <span class="n">ser</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="k">if</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">46340</span><span class="o">**</span><span class="mi">2</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="n">nodata</span> <span class="o">=</span> <span class="n">get_nodata</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ser</span> <span class="o">!=</span> <span class="n">nodata</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">id_map</span> <span class="o">=</span> <span class="n">_idmap</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">ser</span> <span class="o">=</span> <span class="n">ser</span><span class="p">[</span><span class="n">ser</span> <span class="o">!=</span> <span class="n">nodata</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ser</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">id_map</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
        <span class="n">k_nas</span> <span class="o">=</span> <span class="n">k</span> <span class="k">if</span> <span class="n">include_nodata</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">joblib</span>  <span class="c1"># noqa: F401</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parallel processing is requested (n_jobs=</span><span class="si">{</span><span class="n">n_jobs</span><span class="si">}</span><span class="s2">),&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; but joblib cannot be imported. n_jobs will be set&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; to 1.&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sw_tup</span> <span class="o">=</span> <span class="n">_SWbuilder</span><span class="p">(</span>
                <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">id_map</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">k_nas</span><span class="p">,</span> <span class="n">dtype</span>
            <span class="p">)</span>  <span class="c1"># -&gt; (data, (row, col))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="c1"># Parallel implementation</span>
            <span class="n">sw_tup</span> <span class="o">=</span> <span class="n">_parSWbuilder</span><span class="p">(</span>
                <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">id_map</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">k_nas</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_jobs</span>
            <span class="p">)</span>  <span class="c1"># -&gt; (data, (row, col))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fallback method to build sparse matrix</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">lat2SW</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;nodatavals&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">and</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nodatavals&quot;</span><span class="p">]:</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="n">sw</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="n">sw</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sw</span><span class="p">,</span> <span class="n">ser</span>
    <span class="k">return</span> <span class="n">sw_tup</span><span class="p">,</span> <span class="n">ser</span><span class="p">,</span> <span class="n">n</span>


<div class="viewcode-block" id="w2da">
<a class="viewcode-back" href="../../../generated/libpysal.weights.w2da.html#libpysal.weights.w2da">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">w2da</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates xarray.DataArray object from passed data aligned with W object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array/list/pd.Series</span>
<span class="sd">        1d array-like data with dimensionality conforming to w</span>
<span class="sd">    w : libpysal.weights.W</span>
<span class="sd">        Spatial weights object aligned with passed data</span>
<span class="sd">    attrs : Dictionary</span>
<span class="sd">        Attributes stored in dict related to DataArray, e.g. da.attrs</span>
<span class="sd">        Default is {} empty dictionary.</span>
<span class="sd">    coords : Dictionary/xarray.core.coordinates.DataArrayCoordinates</span>
<span class="sd">        Coordinates corresponding to DataArray, e.g. da.coords</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        instance of xarray.DataArray</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from libpysal.raster import da2W, testDataArray, w2da</span>
<span class="sd">    &gt;&gt;&gt; da = testDataArray()</span>
<span class="sd">    &gt;&gt;&gt; da.shape</span>
<span class="sd">    (3, 4, 4)</span>
<span class="sd">    &gt;&gt;&gt; w = da2W(da, z_value=2)</span>
<span class="sd">    &gt;&gt;&gt; data = np.random.randint(0, 255, len(w.index))</span>
<span class="sd">    &gt;&gt;&gt; da1 = w2da(data, w)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;w must be an instance of weights.W&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">):</span>
        <span class="n">da</span> <span class="o">=</span> <span class="n">_index2da</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;This method requires `w` object to include `index` &quot;</span>
            <span class="s2">&quot;attribute that is built as a `pandas.MultiIndex` object.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">da</span></div>



<div class="viewcode-block" id="wsp2da">
<a class="viewcode-back" href="../../../generated/libpysal.weights.wsp2da.html#libpysal.weights.wsp2da">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wsp2da</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wsp</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates xarray.DataArray object from passed data aligned with WSP object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array/list/pd.Series</span>
<span class="sd">        1d array-like data with dimensionality conforming to wsp</span>
<span class="sd">    wsp : libpysal.weights.WSP</span>
<span class="sd">        Sparse weights object aligned with passed data</span>
<span class="sd">    attrs : Dictionary</span>
<span class="sd">        Attributes stored in dict related to DataArray, e.g. da.attrs</span>
<span class="sd">        Default is {} empty dictionary.</span>
<span class="sd">    coords : Dictionary/xarray.core.coordinates.DataArrayCoordinates</span>
<span class="sd">        coordinates corresponding to DataArray, e.g. da.coords</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        instance of xarray.DataArray</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from libpysal.raster import da2WSP, testDataArray, wsp2da</span>
<span class="sd">    &gt;&gt;&gt; da = testDataArray()</span>
<span class="sd">    &gt;&gt;&gt; da.shape</span>
<span class="sd">    (3, 4, 4)</span>
<span class="sd">    &gt;&gt;&gt; wsp = da2WSP(da, z_value=2)</span>
<span class="sd">    &gt;&gt;&gt; data = np.random.randint(0, 255, len(wsp.index))</span>
<span class="sd">    &gt;&gt;&gt; da1 = w2da(data, wsp)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wsp</span><span class="p">,</span> <span class="n">WSP</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;wsp must be an instance of weights.WSP&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wsp</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">):</span>
        <span class="n">da</span> <span class="o">=</span> <span class="n">_index2da</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wsp</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;This method requires `wsp` object to include `index` &quot;</span>
            <span class="s2">&quot;attribute that is built as a `pandas.MultiIndex` object.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">da</span></div>



<div class="viewcode-block" id="testDataArray">
<a class="viewcode-back" href="../../../generated/libpysal.weights.testDataArray.html#libpysal.weights.testDataArray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">testDataArray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing_vals</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates 2 or 3 dimensional test xarray.DataArray object</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        Tuple containing shape of the DataArray aligned with</span>
<span class="sd">        following dimension = (lat, lon) or (layer, lat, lon)</span>
<span class="sd">        Default shape = (3, 4, 4)</span>
<span class="sd">    time : boolean</span>
<span class="sd">        Type of layer, if True then layer=time else layer=band</span>
<span class="sd">        Default is False.</span>
<span class="sd">    rand : boolean</span>
<span class="sd">        If True, creates a DataArray filled with unique and random data.</span>
<span class="sd">        Default is false (generates seeded random data)</span>
<span class="sd">    missing_vals : boolean</span>
<span class="sd">        Create a DataArray filled with missing values. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        instance of xarray.DataArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataArray</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
            <span class="s2">&quot;xarray must be installed to use this functionality&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rand</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span> <span class="k">if</span> <span class="n">time</span> <span class="k">else</span> <span class="s2">&quot;band&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">:</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2020-07-30&quot;</span><span class="p">),</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[D]&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">layers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="n">coords</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">coords</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">missing_vals</span><span class="p">:</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nodatavals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">32768.0</span><span class="p">,)</span>
        <span class="n">miss_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">miss_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nodatavals&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">da</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_da_checker</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">z_value</span><span class="p">,</span> <span class="n">coords_labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    xarray.dataarray checker for raster interface</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        Input 2D or 3D DataArray with shape=(z, y, x)</span>
<span class="sd">    z_value : int/string/float</span>
<span class="sd">        Select the z_value of 3D DataArray with multiple layers.</span>
<span class="sd">    coords_labels : dictionary</span>
<span class="sd">        Pass dimension labels for coordinates and layers if they do not</span>
<span class="sd">        belong to default dimensions, which are (band/time, y/lat, x/lon)</span>
<span class="sd">        e.g. coords_labels = {&quot;y_label&quot;: &quot;latitude&quot;,&quot;</span>
<span class="sd">        &quot;x_label&quot;: &quot;longitude&quot;, &quot;z_label&quot;: &quot;year&quot;}</span>
<span class="sd">        Default is {} empty dictionary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z_id : int</span>
<span class="sd">        Returns the index of layer</span>
<span class="sd">    dims : dictionary</span>
<span class="sd">        Mapped dimensions of the DataArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataArray</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
            <span class="s2">&quot;xarray must be installed to use this functionality&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;da must be an instance of xarray.DataArray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;da must be 2D or 3D&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;da must be an array of integers or float&quot;</span><span class="p">)</span>

    <span class="c1"># default dimensions</span>
    <span class="n">def_labels</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x_label&quot;</span><span class="p">:</span> <span class="n">coords_labels</span><span class="p">[</span><span class="s2">&quot;x_label&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;x_label&quot;</span> <span class="ow">in</span> <span class="n">coords_labels</span>
        <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;lon&quot;</span><span class="p">),</span>
        <span class="s2">&quot;y_label&quot;</span><span class="p">:</span> <span class="n">coords_labels</span><span class="p">[</span><span class="s2">&quot;y_label&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;y_label&quot;</span> <span class="ow">in</span> <span class="n">coords_labels</span>
        <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;lat&quot;</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">def_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">coords_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;z_label&quot;</span> <span class="ow">in</span> <span class="n">coords_labels</span>
            <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;band&quot;</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="s2">&quot;band&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">z_id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">z_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">def_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Multiple layers detected. Using first layer as default.&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_id</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="n">def_labels</span><span class="p">[</span><span class="s2">&quot;z_label&quot;</span><span class="p">]])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">z_value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">z_id</span><span class="p">,</span> <span class="n">def_labels</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_index2da</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates xarray.DataArray object from passed data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array/list/pd.Series</span>
<span class="sd">        1d array-like data with dimensionality conforming to index</span>
<span class="sd">    index : pd.MultiIndex</span>
<span class="sd">        indices of the DataArray when converted to pd.Series</span>
<span class="sd">    attrs : Dictionary</span>
<span class="sd">        Attributes stored in dict related to DataArray, e.g. da.attrs</span>
<span class="sd">    coords : Dictionary/xarray.core.coordinates.DataArrayCoordinates</span>
<span class="sd">        coordinates corresponding to DataArray, e.g. da[n-1:n].coords</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    da : xarray.DataArray</span>
<span class="sd">        instance of xarray.DataArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataArray</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
            <span class="s2">&quot;xarray must be installed to use this functionality&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">names</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lev</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
    <span class="n">nodata</span> <span class="o">=</span> <span class="n">nodata_from_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">nodata</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">min_data</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">min_data</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nodatavals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">fill_value</span><span class="p">])</span>  <span class="c1"># noqa: C409</span>
            <span class="n">data_complete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_complete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">data_complete</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">lev</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="n">nodata</span> <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">data_complete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">data_complete</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="n">da</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">data_complete</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">da</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_idmap</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function computes id_map of non-missing raster data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ids : ndarray</span>
<span class="sd">        1D array containing ids of non-missing raster data</span>
<span class="sd">    mask : ndarray</span>
<span class="sd">        1D array mask array</span>
<span class="sd">    dtype : type</span>
<span class="sd">        Data type of the id_map array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    id_map : ndarray</span>
<span class="sd">        1D array containing id_maps of non-missing raster data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id_map</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="n">id_map</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">id_map</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_SWbuilder</span><span class="p">(</span>
    <span class="n">nrows</span><span class="p">,</span>
    <span class="n">ncols</span><span class="p">,</span>
    <span class="n">ids</span><span class="p">,</span>
    <span class="n">id_map</span><span class="p">,</span>
    <span class="n">criterion</span><span class="p">,</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes data and orders rows, cols, data for a single chunk</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nrows : int</span>
<span class="sd">        Number of rows in the raster data</span>
<span class="sd">    ncols : int</span>
<span class="sd">        Number of columns in the raster data</span>
<span class="sd">    ids : ndarray</span>
<span class="sd">        1D array containing ids of non-missing raster data</span>
<span class="sd">    id_map : ndarray</span>
<span class="sd">        1D array containing id_maps of non-missing raster data</span>
<span class="sd">    criterion : str</span>
<span class="sd">        Type of contiguity.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of contiguity, Default is 1</span>
<span class="sd">    dtype : type</span>
<span class="sd">        Data type of the id_map array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        1D ones array containing weight of each neighbor</span>
<span class="sd">    rows : ndarray</span>
<span class="sd">        1D ones array containing row value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    cols : ndarray</span>
<span class="sd">        1D ones array containing columns value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">_compute_chunk</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">id_map</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_compute_chunk</span><span class="p">(</span>
    <span class="n">nrows</span><span class="p">,</span>
    <span class="n">ncols</span><span class="p">,</span>
    <span class="n">ids</span><span class="p">,</span>
    <span class="n">id_map</span><span class="p">,</span>
    <span class="n">criterion</span><span class="p">,</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes rows cols for a single chunk</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nrows : int</span>
<span class="sd">        Number of rows in the raster data</span>
<span class="sd">    ncols : int</span>
<span class="sd">        Number of columns in the raster data</span>
<span class="sd">    ids : ndarray</span>
<span class="sd">        1D array containing ids of non-missing raster data</span>
<span class="sd">    id_map : ndarray</span>
<span class="sd">        1D array containing id_maps of non-missing raster data</span>
<span class="sd">    criterion : str</span>
<span class="sd">        Type of contiguity.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of contiguity, Default is 1</span>
<span class="sd">    dtype : type</span>
<span class="sd">        Data type of the rows and cols array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rows : ndarray</span>
<span class="sd">        1D ones array containing row value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    cols : ndarray</span>
<span class="sd">        1D ones array containing columns value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    ni : int</span>
<span class="sd">        Number of rows and cols</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="c1"># Setting d which is used for row, col preallocation</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s2">&quot;rook&quot;</span> <span class="k">else</span> <span class="mi">8</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># -&gt; Pointer to store rows and cols in array</span>
    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s2">&quot;queen&quot;</span>
            <span class="k">else</span> <span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">order</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">id_i</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">og_id</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span> <span class="o">%</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">order</span><span class="p">:</span>
                <span class="c1"># east neighbor</span>
                <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">order</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                    <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                    <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># north-east to south-east neighbors</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">id_i</span> <span class="o">//</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nrows</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[(</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">id_i</span> <span class="o">//</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[(</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">id_i</span> <span class="o">//</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nrows</span> <span class="o">-</span> <span class="n">order</span><span class="p">):</span>
                <span class="c1"># south neighbor</span>
                <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">order</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                    <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                    <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># south-west to south-east neighbors</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">id_i</span> <span class="o">%</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s2">&quot;queen&quot;</span> <span class="ow">or</span> <span class="p">((</span><span class="n">k</span> <span class="o">/</span> <span class="n">order</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">2.0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">id_i</span> <span class="o">%</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">order</span><span class="p">:</span>
                        <span class="c1"># south-west neighbor</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">order</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">id_i</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span> <span class="o">%</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">order</span><span class="p">:</span>
                        <span class="c1"># south-east neighbor</span>
                        <span class="n">id_neighbor</span> <span class="o">=</span> <span class="n">id_map</span><span class="p">[</span><span class="n">id_i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span> <span class="o">+</span> <span class="n">order</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">id_neighbor</span><span class="p">:</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">og_id</span><span class="p">,</span> <span class="n">id_neighbor</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">rows</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_neighbor</span><span class="p">,</span> <span class="n">og_id</span>
                            <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">rows</span><span class="p">[:</span><span class="n">ni</span><span class="p">],</span> <span class="n">cols</span><span class="p">[:</span><span class="n">ni</span><span class="p">]</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_chunk_generator</span><span class="p">(</span>
    <span class="n">n_jobs</span><span class="p">,</span>
    <span class="n">starts</span><span class="p">,</span>
    <span class="n">ids</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct chunks to iterate over within numba in parallel</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_jobs : int</span>
<span class="sd">        Number of cores to be used in the sparse weight construction. If -1,</span>
<span class="sd">        all available cores are used.</span>
<span class="sd">    starts : ndarray</span>
<span class="sd">        (n_chunks+1,) array of positional starts for ids chunk</span>
<span class="sd">    ids : ndarray</span>
<span class="sd">        1D array containing ids of non-missing raster data</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    ids_chunk : numpy.ndarray</span>
<span class="sd">        (n_chunk,) array containing the chunk of non-missing raster data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ids_chunk</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">)]</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">ids_chunk</span><span class="p">,)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parSWbuilder</span><span class="p">(</span>
    <span class="n">nrows</span><span class="p">,</span>
    <span class="n">ncols</span><span class="p">,</span>
    <span class="n">ids</span><span class="p">,</span>
    <span class="n">id_map</span><span class="p">,</span>
    <span class="n">criterion</span><span class="p">,</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes data and orders rows, cols, data in parallel using numba</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nrows : int</span>
<span class="sd">        Number of rows in the raster data</span>
<span class="sd">    ncols : int</span>
<span class="sd">        Number of columns in the raster data</span>
<span class="sd">    ids : ndarray</span>
<span class="sd">        1D array containing ids of non-missing raster data</span>
<span class="sd">    id_map : ndarray</span>
<span class="sd">        1D array containing id_maps of non-missing raster data</span>
<span class="sd">    criterion : str</span>
<span class="sd">        Type of contiguity.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of contiguity, Default is 1</span>
<span class="sd">    dtype : type</span>
<span class="sd">        Data type of the rows and cols array</span>
<span class="sd">    n_jobs : int</span>
<span class="sd">        Number of cores to be used in the sparse weight construction. If -1,</span>
<span class="sd">        all available cores are used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        1D ones array containing weight of each neighbor</span>
<span class="sd">    rows : ndarray</span>
<span class="sd">        1D ones array containing row value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    cols : ndarray</span>
<span class="sd">        1D ones array containing columns value of each id</span>
<span class="sd">        in the sparse weight object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">joblib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">parallel_backend</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">n_jobs</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_jobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">_chunk_generator</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s2">&quot;threading&quot;</span><span class="p">):</span>
        <span class="n">worker_out</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_compute_chunk</span><span class="p">)(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="n">id_map</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">chunk</span>
        <span class="p">)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">worker_out</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>