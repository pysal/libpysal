<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>libpysal.graph.base &#8212; libpysal v4.13.0 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pysal-styles.css?v=38b0ce36" />
    <script src="../../../_static/documentation_options.js?v=0080a303"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          libpysal</a>
        <span class="navbar-text navbar-version pull-left"><b>4.13.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../user-guide/intro.html">User Guide</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-released-version">Installing released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-development-version">Installing development version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-graph">Spatial Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-weights">Spatial Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#cg-computational-geometry">cg: Computational Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#io">io</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#examples">examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user-guide/intro.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/data/examples.html">Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/weights/intro.html">Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../user-guide/graph/intro.html">Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../migration.html">W to Graph Member Comparisions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-common-to-w-and-graph">Members common to W and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-common-to-w-and-graph-with-different-types">Members common to W and Graph with different types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-unique-to-w">Members unique to W</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../migration.html#members-unique-to-graph">Members unique to Graph</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for libpysal.graph.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cached_property</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">packaging.version</span><span class="w"> </span><span class="kn">import</span> <span class="n">Version</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">scipy_version</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sparse</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">libpysal.weights</span><span class="w"> </span><span class="kn">import</span> <span class="n">W</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">._contiguity</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_block_contiguity</span><span class="p">,</span>
    <span class="n">_fuzzy_contiguity</span><span class="p">,</span>
    <span class="n">_queen</span><span class="p">,</span>
    <span class="n">_rook</span><span class="p">,</span>
    <span class="n">_vertex_set_intersection</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._indices</span><span class="w"> </span><span class="kn">import</span> <span class="n">_build_from_h3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._kernel</span><span class="w"> </span><span class="kn">import</span> <span class="n">_distance_band</span><span class="p">,</span> <span class="n">_kernel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._matching</span><span class="w"> </span><span class="kn">import</span> <span class="n">_spatial_matching</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._network</span><span class="w"> </span><span class="kn">import</span> <span class="n">build_travel_graph</span> <span class="k">as</span> <span class="n">_build_travel_graph</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">_explore_graph</span><span class="p">,</span> <span class="n">_plot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._raster</span><span class="w"> </span><span class="kn">import</span> <span class="n">_generate_da</span><span class="p">,</span> <span class="n">_raster_contiguity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._set_ops</span><span class="w"> </span><span class="kn">import</span> <span class="n">SetOpsMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._spatial_lag</span><span class="w"> </span><span class="kn">import</span> <span class="n">_lag_spatial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphSummary</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._triangulation</span><span class="w"> </span><span class="kn">import</span> <span class="n">_delaunay</span><span class="p">,</span> <span class="n">_gabriel</span><span class="p">,</span> <span class="n">_relative_neighborhood</span><span class="p">,</span> <span class="n">_voronoi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_compute_stats</span><span class="p">,</span>
    <span class="n">_evaluate_index</span><span class="p">,</span>
    <span class="n">_neighbor_dict_to_edges</span><span class="p">,</span>
    <span class="n">_percentile_filtration_grouper</span><span class="p">,</span>
    <span class="n">_resolve_islands</span><span class="p">,</span>
    <span class="n">_sparse_to_arrays</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.io._gal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_read_gal</span><span class="p">,</span> <span class="n">_to_gal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.io._gwt</span><span class="w"> </span><span class="kn">import</span> <span class="n">_read_gwt</span><span class="p">,</span> <span class="n">_to_gwt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.io._parquet</span><span class="w"> </span><span class="kn">import</span> <span class="n">_read_parquet</span><span class="p">,</span> <span class="n">_to_parquet</span>

<span class="n">ALLOWED_TRANSFORMATIONS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>

<span class="c1"># listed alphabetically</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&quot;</span>
<span class="s2">Martin Fleischmann (martin@martinfleischmann.net)</span>
<span class="s2">Eli Knaap (ek@knaaptime.com)</span>
<span class="s2">Serge Rey (sjsrey@gmail.com)</span>
<span class="s2">Levi John Wolf (levi.john.wolf@gmail.com)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_parquet&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_gal&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_gwt&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="Graph">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="p">(</span><span class="n">SetOpsMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Graph class encoding spatial weights matrices</span>

<span class="sd">    The :class:`Graph` is currently experimental</span>
<span class="sd">    and its API is incomplete and unstable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Graph.__init__">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Weights base class based on adjacency list</span>

<span class="sd">        It is recommenced to use one of the ``from_*`` or ``build_*`` constructors</span>
<span class="sd">        rather than invoking ``__init__`` directly.</span>

<span class="sd">        Each observation needs to be present in the focal,</span>
<span class="sd">        at least as a self-loop with a weight 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjacency : pandas.Series</span>
<span class="sd">            A MultiIndexed pandas.Series with ``&quot;focal&quot;`` and ``&quot;neigbor&quot;`` levels</span>
<span class="sd">            encoding adjacency, and values encoding weights. By convention,</span>
<span class="sd">            isolates are encoded as self-loops with a weight 0.</span>
<span class="sd">        transformation : str, default &quot;O&quot;</span>
<span class="sd">            weights transformation used to produce the table.</span>

<span class="sd">            - **O** -- Original</span>
<span class="sd">            - **B** -- Binary</span>
<span class="sd">            - **R** -- Row-standardization (global sum :math:`=n`)</span>
<span class="sd">            - **D** -- Double-standardization (global sum :math:`=1`)</span>
<span class="sd">            - **V** -- Variance stabilizing</span>
<span class="sd">            - **C** -- Custom</span>
<span class="sd">        is_sorted : bool, default False</span>
<span class="sd">            ``adjacency`` capturing the graph needs to be canonically sorted to</span>
<span class="sd">            initialize the class. The MultiIndex needs to be ordered i--&gt;j</span>
<span class="sd">            on both focal and neighbor levels according to the order of ids in the</span>
<span class="sd">            original data from which the Graph is created. Sorting is performed by</span>
<span class="sd">            default based on the order of unique values in the focal level. Sorting</span>
<span class="sd">            needs to be reflected in both the values of the MultiIndex and also the</span>
<span class="sd">            underlying MultiIndex.codes. Set ``is_sorted=True`` to skip this step if the</span>
<span class="sd">            adjacency is already canonically sorted and you are certain about it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The adjacency table needs to be a pandas.Series. </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">adjacency</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The index of the adjacency table needs to be a MultiIndex named &quot;</span>
                <span class="s2">&quot;[&#39;focal&#39;, &#39;neighbor&#39;].&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The adjacency needs to be named &#39;weight&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; was given instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">adjacency</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;weight&#39; needs to be of a numeric dtype. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39; dtype was given instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The adjacency table cannot contain missing values.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_TRANSFORMATIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;transformation&#39; needs to be one of </span><span class="si">{</span><span class="n">ALLOWED_TRANSFORMATIONS</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">transformation</span><span class="si">}</span><span class="s2">&#39; was given instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sorted</span><span class="p">:</span>
            <span class="c1"># adjacency always ordered i--&gt;j on both levels</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">adjacency</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">=</span> <span class="n">adjacency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="n">transformation</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Easy lookup based on focal index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : hashable</span>
<span class="sd">            hashable represting an index value</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            subset of the adjacency table for `item`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="p">[],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_ids_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="mi">72</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">chars</span><span class="p">:</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())[:</span><span class="n">chars</span><span class="p">]</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ids</span><span class="si">}</span><span class="s2">...]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;Graph of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2"> nodes and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span><span class="si">}</span><span class="s2"> nonzero edges indexed by</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ids_repr</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Graph.copy">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a copy of this Graph&#39;s adjacency table and transformation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, optional</span>
<span class="sd">            Make a deep copy of the adjacency table, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph as a copy of the original</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">),</span>
            <span class="n">transformation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">,</span>
            <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the adjacency list</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            Underlying adjacency list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Graph.from_W">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_W">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_W</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>  <span class="c1"># noqa: N802</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an experimental Graph from libpysal.weights.W object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w : libpysal.weights.W</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph from W</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; queen_w = weights.Queen.from_dataframe(nybb, use_index=True)</span>
<span class="sd">        &gt;&gt;&gt; queen_graph = graph.Graph.from_W(queen_w)</span>
<span class="sd">        &gt;&gt;&gt; queen_graph</span>
<span class="sd">        &lt;Graph of 5 nodes and 10 nonzero edges indexed by</span>
<span class="sd">         [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_weights_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.to_W">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_W">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_W</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: N802</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Graph to a libpysal.weights.W object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        libpysal.weights.W</span>
<span class="sd">            representation of graph as a weights.W object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0</span>
<span class="sd">        Queens         Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Brooklyn       Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Manhattan      Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Bronx          Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; w = contiguity.to_W()</span>
<span class="sd">        &gt;&gt;&gt; w.neighbors</span>
<span class="sd">        {&#39;Bronx&#39;: [&#39;Queens&#39;, &#39;Manhattan&#39;],</span>
<span class="sd">         &#39;Brooklyn&#39;: [&#39;Queens&#39;, &#39;Manhattan&#39;],</span>
<span class="sd">         &#39;Manhattan&#39;: [&#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Bronx&#39;],</span>
<span class="sd">         &#39;Queens&#39;: [&#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;],</span>
<span class="sd">         &#39;Staten Island&#39;: []}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">grouper</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">W</span><span class="p">(</span>
            <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">id_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">silence_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_adjacency">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_adjacency">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_adjacency</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">adjacency</span><span class="p">,</span> <span class="n">focal_col</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="n">neighbor_col</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span> <span class="n">weight_col</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Graph from a pandas DataFrame formatted as an adjacency list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjacency : pandas.DataFrame</span>
<span class="sd">            a dataframe formatted as an ajacency list. Should have columns</span>
<span class="sd">            &quot;focal&quot;, &quot;neighbor&quot;, and &quot;weight&quot;, or columns that can be mapped</span>
<span class="sd">            to these (e.g. origin, destination, cost)</span>
<span class="sd">        focal : str, optional</span>
<span class="sd">            name of column holding focal/origin index, by default &#39;focal&#39;</span>
<span class="sd">        neighbor : str, optional</span>
<span class="sd">            name of column holding neighbor/destination index, by default &#39;neighbor&#39;</span>
<span class="sd">        weight : str, optional</span>
<span class="sd">            name of column holding weight values, by default &#39;weight&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">[</span><span class="n">focal_col</span><span class="p">,</span> <span class="n">neighbor_col</span><span class="p">,</span> <span class="n">weight_col</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;focal_col&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_col&quot;</span><span class="p">,</span> <span class="s2">&quot;weight_col&quot;</span><span class="p">],</span>
                <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s1">&quot; was given for `</span><span class="si">{</span><span class="n">cols</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="si">}</span><span class="s1">`, but the &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;columns available in `adjacency` are:  </span><span class="si">{</span><span class="n">adjacency</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">focal_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">neighbor_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">adjacency</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_sparse">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_sparse">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_sparse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a ``scipy.sparse`` array to a PySAL ``Graph`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sparse : scipy.sparse array</span>
<span class="sd">            sparse representation of a graph</span>
<span class="sd">        ids : list-like, default None</span>
<span class="sd">            list-like of ids for geometries that is mappable to</span>
<span class="sd">            positions from sparse. If None, the positions are used as labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on sparse</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">_sparse_to_arrays</span><span class="p">(</span><span class="n">sparse</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">return_adjacency</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_arrays">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_arrays">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_arrays</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">focal_ids</span><span class="p">,</span> <span class="n">neighbor_ids</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from arrays of indices and weights of the same length</span>

<span class="sd">        The arrays needs to be sorted in a way ensuring that focal_ids.unique() is</span>
<span class="sd">        equal to the index of original observations from which the Graph is being built</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        focal_index : array-like</span>
<span class="sd">            focal indices</span>
<span class="sd">        neighbor_index : array-like</span>
<span class="sd">            neighbor indices</span>
<span class="sd">        weight : array-like</span>
<span class="sd">            weights</span>
<span class="sd">        **kwargs</span>
<span class="sd">            keyword arguments passed to the class constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">weight</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">focal_ids</span><span class="p">,</span> <span class="n">neighbor_ids</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="Graph.from_weights_dict">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_weights_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_weights_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">weights_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from a dict of dicts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights_dict : dictionary of dictionaries</span>
<span class="sd">            weights dictionary with the ``{focal: {neighbor: weight}}`` structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on weights dictionary of dictionaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">weights_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">weights_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.from_dicts">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.from_dicts">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dicts</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from dictionaries of neighbors and weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        neighbors : dict</span>
<span class="sd">            dictionary of neighbors with the ``{focal: [neighbor1, neighbor2]}``</span>
<span class="sd">            structure</span>
<span class="sd">        weights : dict, optional</span>
<span class="sd">            dictionary of neighbors with the ``{focal: [weight1, weight2]}``</span>
<span class="sd">            structure. If None, assumes binary weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph based on dictionaries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; neighbors = {</span>
<span class="sd">        ...     &#39;Africa&#39;: [&#39;Asia&#39;],</span>
<span class="sd">        ...     &#39;Asia&#39;: [&#39;Africa&#39;, &#39;Europe&#39;],</span>
<span class="sd">        ...     &#39;Australia&#39;: [],</span>
<span class="sd">        ...     &#39;Europe&#39;: [&#39;Asia&#39;],</span>
<span class="sd">        ...     &#39;North America&#39;: [&#39;South America&#39;],</span>
<span class="sd">        ...     &#39;South America&#39;: [&#39;North America&#39;],</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; connectivity = graph.Graph.from_dicts(neighbors)</span>
<span class="sd">        &gt;&gt;&gt; connectivity.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Africa         Asia             1</span>
<span class="sd">        Asia           Africa           1</span>
<span class="sd">                       Europe           1</span>
<span class="sd">        Australia      Australia        0</span>
<span class="sd">        Europe         Asia             1</span>
<span class="sd">        North America  South America    1</span>
<span class="sd">        South America  North America    1</span>
<span class="sd">        Name: weight, dtype: float64</span>

<span class="sd">        You can also specify weights (for example based</span>
<span class="sd">        on the length of the shared border):</span>

<span class="sd">        &gt;&gt;&gt; weights = {</span>
<span class="sd">        ...     &#39;Africa&#39;: [1],</span>
<span class="sd">        ...     &#39;Asia&#39;: [0.2, 0.8],</span>
<span class="sd">        ...     &#39;Australia&#39;: [],</span>
<span class="sd">        ...     &#39;Europe&#39;: [1],</span>
<span class="sd">        ...     &#39;North America&#39;: [1],</span>
<span class="sd">        ...     &#39;South America&#39;: [1],</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; connectivity = graph.Graph.from_dicts(neighbors, weights)</span>
<span class="sd">        &gt;&gt;&gt; connectivity.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Africa         Asia             1.0</span>
<span class="sd">        Asia           Africa           0.2</span>
<span class="sd">                       Europe           0.8</span>
<span class="sd">        Australia      Australia        0.0</span>
<span class="sd">        Europe         Asia             1.0</span>
<span class="sd">        North America  South America    1.0</span>
<span class="sd">        South America  North America    1.0</span>
<span class="sd">        Name: weight, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_neighbor_dict_to_edges</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_block_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_block_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_block_contiguity</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">regimes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from block contiguity (regime neighbors)</span>

<span class="sd">        Block contiguity structures are relevant when defining neighbor relations</span>
<span class="sd">        based on membership in a regime. For example, all counties belonging to</span>
<span class="sd">        the same state could be defined as neighbors, in an analysis of all</span>
<span class="sd">        counties in the US.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regimes : list-like</span>
<span class="sd">            list-like of regimes. If pandas.Series, its index is used to encode Graph.</span>
<span class="sd">            Otherwise a default RangeIndex is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding block contiguity</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; france = gpd.read_file(get_path(&#39;geoda guerry&#39;)).set_index(&#39;Dprmnt&#39;)</span>

<span class="sd">        In the GeoDa Guerry dataset, the Region column reflects the region</span>
<span class="sd">        (North, East, West, South or Central) to which each department belongs.</span>

<span class="sd">        &gt;&gt;&gt; france[[&#39;Region&#39;, &#39;geometry&#39;]].head()</span>
<span class="sd">                     Region                                           geometry</span>
<span class="sd">        Dprtmnt</span>
<span class="sd">        Ain               E  POLYGON ((801150.000 2092615.000, 800669.000 2...</span>
<span class="sd">        Aisne             N  POLYGON ((729326.000 2521619.000, 729320.000 2...</span>
<span class="sd">        Allier            C  POLYGON ((710830.000 2137350.000, 711746.000 2...</span>
<span class="sd">        Basses-Alpes      E  POLYGON ((882701.000 1920024.000, 882408.000 1...</span>
<span class="sd">        Hautes-Alpes      E  POLYGON ((886504.000 1922890.000, 885733.000 1...</span>

<span class="sd">        Using the ``&quot;Region&quot;`` labels as ``regimes`` then identifies all departments</span>
<span class="sd">        within the region as neighbors.</span>

<span class="sd">        &gt;&gt;&gt; block_contiguity = graph.Graph.build_block_contiguity(france[&#39;Region&#39;])</span>
<span class="sd">        &gt;&gt;&gt; block_contiguity.adjacency</span>
<span class="sd">        focal   neighbor</span>
<span class="sd">        Ain     Basses-Alpes       1</span>
<span class="sd">                Hautes-Alpes       1</span>
<span class="sd">                Aube               1</span>
<span class="sd">                Cote-d&#39;Or          1</span>
<span class="sd">                Doubs              1</span>
<span class="sd">                                  ..</span>
<span class="sd">        Vienne  Mayenne            1</span>
<span class="sd">                Morbihan           1</span>
<span class="sd">                Basses-Pyrenees    1</span>
<span class="sd">                Deux-Sevres        1</span>
<span class="sd">                Vendee             1</span>
<span class="sd">        Name: weight, Length: 1360, dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">regimes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">_block_contiguity</span><span class="p">(</span><span class="n">regimes</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">))</span></div>


<div class="viewcode-block" id="Graph.build_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_contiguity</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on contiguity</span>

<span class="sd">        Contiguity builder assumes that all geometries are forming a coverage, i.e.</span>
<span class="sd">        a non-overlapping mesh and neighbouring geometries share only points or</span>
<span class="sd">        segments of their exterior boundaries. In practice, ``build_contiguity`` is</span>
<span class="sd">        capable of creating a Graph of partially overlapping geometries when</span>
<span class="sd">        ``strict=False, by_perimeter=False``, but that would not strictly follow the</span>
<span class="sd">        definition of queen or rook contiguity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : array-like of shapely.Geometry objects</span>
<span class="sd">            Could be geopandas.GeoSeries or geopandas.GeoDataFrame, in which case the</span>
<span class="sd">            resulting Graph is indexed by the original index. If an array of</span>
<span class="sd">            shapely.Geometry objects is passed, Graph will assume a RangeIndex.</span>
<span class="sd">        rook : bool, optional</span>
<span class="sd">            Contiguity method. If True, two geometries are considered neighbours if</span>
<span class="sd">            they share at least one edge. If False, two geometries are considered</span>
<span class="sd">            neighbours if they share at least one vertex. By default True</span>
<span class="sd">        by_perimeter : bool, optional</span>
<span class="sd">            If True, ``weight`` represents the length of the shared boundary between</span>
<span class="sd">            adjacent units, by default False. For row-standardized version of perimeter</span>
<span class="sd">            weights, use</span>
<span class="sd">            ``Graph.build_contiguity(gdf, by_perimeter=True).transform(&quot;r&quot;)``.</span>
<span class="sd">        strict : bool, optional</span>
<span class="sd">            Use the strict topological method. If False, the contiguity is determined</span>
<span class="sd">            based on shared coordinates or coordinate sequences representing edges.</span>
<span class="sd">            This assumes geometry coverage that is topologically correct. This method</span>
<span class="sd">            is faster but can miss some relations. If True, the contiguity is</span>
<span class="sd">            determined based on geometric relations that do not require precise</span>
<span class="sd">            topology. This method is slower but will result in correct contiguity</span>
<span class="sd">            even if the topology of geometries is not optimal. By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding contiguity weights</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0</span>
<span class="sd">        Queens         Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Brooklyn       Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Manhattan      Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Bronx          Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int64</span>

<span class="sd">        Weight by perimeter instead of binary weights:</span>

<span class="sd">        &gt;&gt;&gt; contiguity_perimeter = graph.Graph.build_contiguity(nybb, by_perimeter=True)</span>
<span class="sd">        &gt;&gt;&gt; contiguity_perimeter.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island        0.000000</span>
<span class="sd">        Queens         Brooklyn         50867.502055</span>
<span class="sd">                       Manhattan          103.745207</span>
<span class="sd">                       Bronx                5.777002</span>
<span class="sd">        Brooklyn       Queens           50867.502055</span>
<span class="sd">                       Manhattan         5736.546898</span>
<span class="sd">        Manhattan      Queens             103.745207</span>
<span class="sd">                       Brooklyn          5736.546898</span>
<span class="sd">                       Bronx             5258.300879</span>
<span class="sd">        Bronx          Queens               5.777002</span>
<span class="sd">                       Manhattan         5258.300879</span>
<span class="sd">        Name: weight, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">):</span>
            <span class="c1"># potentially cast GeoDataFrame to GeoSeries</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geometry</span>

        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># use shapely-based constructors</span>
            <span class="k">if</span> <span class="n">rook</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">_rook</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                <span class="o">*</span><span class="n">_queen</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># use vertex-based constructor</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="o">*</span><span class="n">_vertex_set_intersection</span><span class="p">(</span>
                <span class="n">geometry</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="n">rook</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">by_perimeter</span><span class="o">=</span><span class="n">by_perimeter</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_distance_band">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_distance_band">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_distance_band</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on a distance band</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries containing locations to compute the</span>
<span class="sd">            delaunay triangulation. If a geopandas object with Point</span>
<span class="sd">            geometry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geometry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        threshold : float</span>
<span class="sd">            distance band</span>
<span class="sd">        binary : bool, optional</span>
<span class="sd">            If True :math:`w_{ij}=1` if :math:`d_{i,j}&lt;=threshold`, otherwise</span>
<span class="sd">            :math:`w_{i,j}=0`.</span>
<span class="sd">            If False :math:`wij=dij^{alpha}`, by default True.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            distance decay parameter for weight (default -1.0)</span>
<span class="sd">            if alpha is positive the weights will not decline with</span>
<span class="sd">            distance. Ignored if ``binary=True`` or ``kernel`` is not None.</span>
<span class="sd">        kernel : str, optional</span>
<span class="sd">            kernel function to use in order to weight the output graph. See</span>
<span class="sd">            :meth:`Graph.build_kernel` for details. Ignored if ``binary=True``.</span>
<span class="sd">        bandwidth : float (default: None)</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates. Ignored if ``binary=True`` or ``kernel=None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding distance band weights</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        Note that the method requires point geometry (or an array of coordinates</span>
<span class="sd">        representing points) as an input.</span>

<span class="sd">        The threshold distance is in the units of the geometry projection.</span>
<span class="sd">        You can check it using the ``nybb.crs`` property.</span>

<span class="sd">        &gt;&gt;&gt; distance_band = graph.Graph.build_distance_band(nybb.centroid, 45000)</span>
<span class="sd">        &gt;&gt;&gt; distance_band.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0</span>
<span class="sd">        Queens         Brooklyn         1</span>
<span class="sd">        Brooklyn       Queens           1</span>
<span class="sd">        Manhattan      Bronx            1</span>
<span class="sd">        Bronx          Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int64</span>

<span class="sd">        The larger threshold yields more neighbors.</span>

<span class="sd">        &gt;&gt;&gt; distance_band = graph.Graph.build_distance_band(nybb.centroid, 110000)</span>
<span class="sd">        &gt;&gt;&gt; distance_band.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Queens         Staten Island    1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Brooklyn       Staten Island    1</span>
<span class="sd">                       Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Manhattan      Staten Island    1</span>
<span class="sd">                       Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Bronx          Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int64</span>

<span class="sd">        Instead of binary weights you can use inverse distance.</span>

<span class="sd">        &gt;&gt;&gt; distance_band = graph.Graph.build_distance_band(</span>
<span class="sd">        ...     nybb.centroid,</span>
<span class="sd">        ...     45000,</span>
<span class="sd">        ...     binary=False,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; distance_band.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0.000000</span>
<span class="sd">        Queens         Brooklyn         0.000024</span>
<span class="sd">        Brooklyn       Queens           0.000024</span>
<span class="sd">        Manhattan      Bronx            0.000026</span>
<span class="sd">        Bronx          Manhattan        0.000026</span>
<span class="sd">        Name: weight, dtype: float64</span>

<span class="sd">        Or specify the kernel function to derive weight from the distance.</span>

<span class="sd">        &gt;&gt;&gt; distance_band = graph.Graph.build_distance_band(</span>
<span class="sd">        ...     nybb.centroid,</span>
<span class="sd">        ...     45000,</span>
<span class="sd">        ...     binary=False,</span>
<span class="sd">        ...     kernel=&#39;bisquare&#39;,</span>
<span class="sd">        ...     bandwidth=60000,</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; distance_band.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0.000000</span>
<span class="sd">        Queens         Brooklyn         0.232079</span>
<span class="sd">        Brooklyn       Queens           0.232079</span>
<span class="sd">        Manhattan      Bronx            0.309825</span>
<span class="sd">        Bronx          Manhattan        0.309825</span>
<span class="sd">        Name: weight, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">_distance_band</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="k">lambda</span> <span class="n">distances</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">alpha</span><span class="p">),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="n">head</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="n">tail</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>
        <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span>

        <span class="c1"># drop diagonal</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">no_isolates</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">adjacency</span><span class="p">[</span>
            <span class="o">~</span><span class="p">(</span>
                <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">no_isolates</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">adjacency</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># set isolates to 0 - distance band should never contain self-weight</span>
        <span class="n">adjacency</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">no_isolates</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="n">adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">values</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_fuzzy_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_fuzzy_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_fuzzy_contiguity</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from fuzzy contiguity</span>

<span class="sd">        Fuzzy contiguity relaxes the notion of contiguity neighbors</span>
<span class="sd">        for the case of geometry collections that violate the condition</span>
<span class="sd">        of planar enforcement. It handles three types of conditions present</span>
<span class="sd">        in such collections that would result in missing links when using</span>
<span class="sd">        the regular contiguity methods.</span>

<span class="sd">        The first are edges for nearby polygons that should be shared, but are</span>
<span class="sd">        digitized separately for the individual polygons and the resulting edges</span>
<span class="sd">        do not coincide, but instead the edges intersect. This case can also be</span>
<span class="sd">        covered by ``build_contiguty`` with the ``strict=False`` parameter.</span>

<span class="sd">        The second case is similar to the first, only the resultant edges do not</span>
<span class="sd">        intersect but are &quot;close&quot;. The optional buffering of geometry then closes the</span>
<span class="sd">        gaps between the polygons and a resulting intersection is encoded as a link.</span>

<span class="sd">        The final case arises when one polygon is &quot;inside&quot; a second polygon but is not</span>
<span class="sd">        encoded to represent a hole in the containing polygon.</span>

<span class="sd">        It is also possible to create a contiguity based on a custom spatial predicate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geoms :  array-like of shapely.Geometry objects</span>
<span class="sd">            Could be geopandas.GeoSeries or geopandas.GeoDataFrame, in which case the</span>
<span class="sd">            resulting Graph is indexed by the original index. If an array of</span>
<span class="sd">            shapely.Geometry objects is passed, Graph will assume a RangeIndex.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The percentage of the length of the minimum side of the bounding rectangle</span>
<span class="sd">            for the ``geoms`` to use in determining the buffering distance. Either</span>
<span class="sd">            ``tolerance`` or ``buffer`` may be specified but not both.</span>
<span class="sd">            By default None.</span>
<span class="sd">        buffer : float, optional</span>
<span class="sd">            Exact buffering distance in the units of ``geoms.crs``. Either</span>
<span class="sd">            ``tolerance`` or ``buffer`` may be specified but not both.</span>
<span class="sd">            By default None.</span>
<span class="sd">        predicate : str, optional</span>
<span class="sd">            The predicate to use for determination of neighbors. Default is</span>
<span class="sd">            &#39;intersects&#39;. If None is passed, neighbours are determined based</span>
<span class="sd">            on the intersection of bounding boxes. See the documentation of</span>
<span class="sd">            ``geopandas.GeoSeries.sindex.query`` for allowed predicates.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments passed to ``geopandas.GeoSeries.buffer``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding fuzzy contiguity</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        Example using the default parameters:</span>

<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity = graph.Graph.build_fuzzy_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity</span>
<span class="sd">        &lt;Graph of 5 nodes and 10 nonzero edges indexed by</span>
<span class="sd">         [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>

<span class="sd">        Example using the tolerance of 0.05:</span>

<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity = graph.Graph.build_fuzzy_contiguity(nybb, tolerance=0.05)</span>
<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity</span>
<span class="sd">        &lt;Graph of 5 nodes and 12 nonzero edges indexed by</span>
<span class="sd">         [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>

<span class="sd">        Example using a buffer of 10000 feet (CRS of nybb is in feet):</span>

<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity = graph.Graph.build_fuzzy_contiguity(nybb, buffer=10000)</span>
<span class="sd">        &gt;&gt;&gt; fuzzy_contiguity</span>
<span class="sd">        &lt;Graph of 5 nodes and 14 nonzero edges indexed by</span>
<span class="sd">         [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>

        <span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_fuzzy_contiguity</span><span class="p">(</span>
            <span class="n">geometry</span><span class="p">,</span>
            <span class="n">ids</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_raster_contiguity">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_raster_contiguity">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_raster_contiguity</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">da</span><span class="p">,</span>
        <span class="n">rook</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">z_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coords_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">include_nodata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from ``xarray.DataArray`` raster object</span>

<span class="sd">        Create Graph object encoding contiguity of raster cells from</span>
<span class="sd">        ``xarray.DataArray`` object. The coordinates are flatten to tuples representing</span>
<span class="sd">        the location of each cell within the raster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        da : xarray.DataArray</span>
<span class="sd">            Input 2D or 3D DataArray with shape=(z, y, x)</span>
<span class="sd">        rook : bool, optional</span>
<span class="sd">            Contiguity method. If True, two cells are considered neighbours if</span>
<span class="sd">            they share at least one edge. If False, two geometries are considered</span>
<span class="sd">            neighbours if they share at least one vertex. By default True</span>
<span class="sd">        z_value : {int, str, float}, optional</span>
<span class="sd">            Select the z_value of 3D DataArray with multiple layers. By default None</span>
<span class="sd">        coords_labels : dict, optional</span>
<span class="sd">            Pass dimension labels for coordinates and layers if they do not</span>
<span class="sd">            belong to default dimensions, which are (band/time, y/lat, x/lon)</span>
<span class="sd">            e.g. ``coords_labels = {&quot;y_label&quot;: &quot;latitude&quot;, &quot;x_label&quot;: &quot;longitude&quot;,</span>
<span class="sd">            &quot;z_label&quot;: &quot;year&quot;}``</span>
<span class="sd">            When None, defaults to empty dictionary.</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Order of contiguity, this will select all neighbors up to k-th order.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        include_nodata : bool, optional</span>
<span class="sd">            If True, missing values will be assumed as non-missing when</span>
<span class="sd">            selecting higher_order neighbors, Default is False</span>
<span class="sd">        n_jobs : int, optional</span>
<span class="sd">            Number of cores to be used in the sparse weight construction. If -1,</span>
<span class="sd">            all available cores are used. Default is 1. Requires ``joblib``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding raster contiguity</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">coords_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">criterion</span> <span class="o">=</span> <span class="s2">&quot;rook&quot;</span> <span class="k">if</span> <span class="n">rook</span> <span class="k">else</span> <span class="s2">&quot;queen&quot;</span>

        <span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">xarray_index</span> <span class="o">=</span> <span class="n">_raster_contiguity</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
            <span class="n">z_value</span><span class="o">=</span><span class="n">z_value</span><span class="p">,</span>
            <span class="n">coords_labels</span><span class="o">=</span><span class="n">coords_labels</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">include_nodata</span><span class="o">=</span><span class="n">include_nodata</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_resolve_islands</span><span class="p">(</span>
            <span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">xarray_index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">weights</span>
        <span class="p">)</span>
        <span class="n">contig</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">contig</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="n">xarray_index</span><span class="o">.</span><span class="n">names</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_nodata</span><span class="p">:</span>
            <span class="n">contig</span> <span class="o">=</span> <span class="n">contig</span><span class="o">.</span><span class="n">higher_order</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">lower_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contig</span></div>


<div class="viewcode-block" id="Graph.build_kernel">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_kernel">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_kernel</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">coplanar</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry data based on a kernel function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries over which to compute a kernel. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates. If metric=&quot;precomputed&quot;, data is assumed to contain a</span>
<span class="sd">            precomputed distance metric.</span>
<span class="sd">        kernel : string or callable (default: &#39;gaussian&#39;)</span>
<span class="sd">            kernel function to apply over the distance matrix computed by `metric`.</span>
<span class="sd">            The following kernels are supported:</span>

<span class="sd">            - ``&quot;triangular&quot;``:</span>
<span class="sd">            - ``&quot;parabolic&quot;``:</span>
<span class="sd">            - ``&quot;gaussian&quot;``:</span>
<span class="sd">            - ``&quot;bisquare&quot;``:</span>
<span class="sd">            - ``&quot;cosine&quot;``:</span>
<span class="sd">            - ``&#39;boxcar&#39;``/discrete: all distances less than `bandwidth` are 1, and all</span>
<span class="sd">              other distances are 0</span>
<span class="sd">            - ``&quot;identity&quot;``/None : do nothing, weight similarity based on raw distance</span>
<span class="sd">            - ``callable`` : a user-defined function that takes the distance vector and</span>
<span class="sd">              the bandwidth and returns the kernel: kernel(distances, bandwidth)</span>

<span class="sd">        k : int (default: None)</span>
<span class="sd">            number of nearest neighbors used to truncate the kernel. This is assumed</span>
<span class="sd">            to be constant across samples. If None, no truncation is conduted.</span>
<span class="sd">        bandwidth : float (default: None)</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates.</span>
<span class="sd">        metric : string or callable (default: &#39;euclidean&#39;)</span>
<span class="sd">            distance function to apply over the input coordinates. Supported options</span>
<span class="sd">            depend on whether or not scikit-learn is installed. If so, then any</span>
<span class="sd">            distance function supported by scikit-learn is supported here. Otherwise,</span>
<span class="sd">            only euclidean, minkowski, and manhattan/cityblock distances are admitted.</span>
<span class="sd">        p : int (default: 2)</span>
<span class="sd">            parameter for minkowski metric, ignored if metric != &quot;minkowski&quot;.</span>
<span class="sd">        coplanar: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coplanar points when ``k`` is not None. Options are</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coplanar points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coplanar points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coplanar points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding kernel weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_knn">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_knn">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_knn</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">coplanar</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry data based on k-nearest neighbors search</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries over which to compute a kernel. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        k : int</span>
<span class="sd">            number of nearest neighbors.</span>
<span class="sd">        metric : string or callable (default: &#39;euclidean&#39;)</span>
<span class="sd">            distance function to apply over the input coordinates. Supported options</span>
<span class="sd">            depend on whether or not scikit-learn is installed. If so, then any</span>
<span class="sd">            distance function supported by scikit-learn is supported here. Otherwise,</span>
<span class="sd">            only euclidean, minkowski, and manhattan/cityblock distances are admitted.</span>
<span class="sd">        p : int (default: 2)</span>
<span class="sd">            parameter for minkowski metric, ignored if metric != &quot;minkowski&quot;.</span>
<span class="sd">        coplanar: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coplanar points. Options include</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coplanar points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coplanar points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coplanar points).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding KNN weights</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&#39;BoroName&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>

<span class="sd">        &gt;&gt;&gt; knn3 = graph.Graph.build_knn(nybb.centroid, k=3)</span>
<span class="sd">        &gt;&gt;&gt; knn3.adjacency</span>
<span class="sd">        focal           neighbor</span>
<span class="sd">        Staten Island   Queens           1</span>
<span class="sd">                        Brooklyn         1</span>
<span class="sd">                        Manhattan        1</span>
<span class="sd">        Queens          Brooklyn         1</span>
<span class="sd">                        Manhattan        1</span>
<span class="sd">                        Bronx            1</span>
<span class="sd">        Brooklyn        Staten Island    1</span>
<span class="sd">                        Queens           1</span>
<span class="sd">                        Manhattan        1</span>
<span class="sd">        Manhattan       Queens           1</span>
<span class="sd">                        Brooklyn         1</span>
<span class="sd">                        Bronx            1</span>
<span class="sd">        Bronx           Queens           1</span>
<span class="sd">                        Brooklyn         1</span>
<span class="sd">                        Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int32</span>

<span class="sd">        Specifying k=1 identifies the nearest neighbor</span>
<span class="sd">        (note that this can be asymmetrical):</span>

<span class="sd">        &gt;&gt;&gt; knn1 = graph.Graph.build_knn(nybb.centroid, k=1)</span>
<span class="sd">        &gt;&gt;&gt; knn1.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Brooklyn     1</span>
<span class="sd">        Queens         Brooklyn     1</span>
<span class="sd">        Brooklyn       Queens       1</span>
<span class="sd">        Manhattan      Bronx        1</span>
<span class="sd">        Bronx          Manhattan    1</span>
<span class="sd">        Name: weight, dtype: int32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_spatial_matches">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_spatial_matches">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_spatial_matches</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
        <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_partial_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">metric_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Match locations in one dataset to at least `n_matches`</span>
<span class="sd">        locations in another (possibly identical) dataset</span>
<span class="sd">        by minimizing the total distance between matched locations.</span>

<span class="sd">        Letting :math:`d_{ij}` be</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\text{minimize} \\sum_i^n \\sum_j^n  d_{ij}m_{ij}</span>

<span class="sd">            \\text{subject to}</span>
<span class="sd">                \\sum_j^n m_{ij} &gt;= k \\forall i</span>

<span class="sd">                m_{ij} \\in {0,1} \\forall ij</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries that need matches. If a geopandas.Geo* object</span>
<span class="sd">            is provided, the .geometry attribute is used. If a numpy.ndarray with</span>
<span class="sd">            a geometry dtype is used, then the coordinates are extracted and used.</span>
<span class="sd">        y : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame (default: None)</span>
<span class="sd">            geometries that are used as a source for matching. If a geopandas object</span>
<span class="sd">            is provided, the .geometry attribute is used. If a numpy.ndarray with</span>
<span class="sd">            a geometry dtype is used, then the coordinates are extracted and</span>
<span class="sd">            used. If none, matches are made within `x`.</span>
<span class="sd">        n_matches : int (default: None)</span>
<span class="sd">            number of matches</span>
<span class="sd">        metric : string or callable (default: &#39;euclidean&#39;)</span>
<span class="sd">            distance function to apply over the input coordinates. Supported options</span>
<span class="sd">            depend on whether or not scikit-learn is installed. If so, then any</span>
<span class="sd">            distance function supported by scikit-learn is supported here. Otherwise,</span>
<span class="sd">            only euclidean, minkowski, and manhattan/cityblock distances are admitted.</span>
<span class="sd">        solver : solver from pulp (default: None)</span>
<span class="sd">            a solver defined by the pulp optimization library. If no solver is</span>
<span class="sd">            provided, pulp&#39;s default solver will be used. This is generally</span>
<span class="sd">            pulp.COIN(), but this may vary depending on your configuration.</span>
<span class="sd">        return_mip : bool (default: False)</span>
<span class="sd">            whether or not to return the instance of the pulp.LpProblem. By</span>
<span class="sd">            default, the problem is not returned to the user.</span>
<span class="sd">        allow_partial_match : bool (default: False)</span>
<span class="sd">            whether to allow for partial matching. A partial match may have</span>
<span class="sd">            a weight between zero and one, while a &quot;full&quot; match (by default)</span>
<span class="sd">            must have a weight of either zero or one. A partial matching may</span>
<span class="sd">            have a shorter total distance, but will result in a weighted</span>
<span class="sd">            graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_spatial_matching</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">n_matches</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
            <span class="n">allow_partial_match</span><span class="o">=</span><span class="n">allow_partial_match</span><span class="p">,</span>
            <span class="o">**</span><span class="n">metric_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># ids need to be addressed here, rather than in the matching</span>
        <span class="c1"># because x and y can have different id sets. It&#39;s only</span>
        <span class="c1"># in W where we *know* we can just use one id vector.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_triangulation">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_triangulation">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_triangulation</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delaunay&quot;</span><span class="p">,</span>
        <span class="n">bandwidth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span>
        <span class="n">clip</span><span class="o">=</span><span class="s2">&quot;bounding_box&quot;</span><span class="p">,</span>
        <span class="n">rook</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">coplanar</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from geometry based on triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray, geopandas.GeoSeries, geopandas.GeoDataFrame</span>
<span class="sd">            geometries containing locations to compute the</span>
<span class="sd">            delaunay triangulation. If a geopandas object with Point</span>
<span class="sd">            geoemtry is provided, the .geometry attribute is used. If a numpy.ndarray</span>
<span class="sd">            with shapely geoemtry is used, then the coordinates are extracted and used.</span>
<span class="sd">            If a numpy.ndarray of a shape (2,n) is used, it is assumed to contain x, y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        method : str, (default &quot;delaunay&quot;)</span>
<span class="sd">            method of extracting the weights from triangulation. Supports:</span>

<span class="sd">            - ``&quot;delaunay&quot;``</span>
<span class="sd">            - ``&quot;gabriel&quot;``</span>
<span class="sd">            - ``&quot;relative_neighborhood&quot;``</span>
<span class="sd">            - ``&quot;voronoi&quot;``</span>

<span class="sd">        bandwidth : float, optional</span>
<span class="sd">            distance to use in the kernel computation. Should be on the same scale as</span>
<span class="sd">            the input coordinates, by default numpy.inf</span>
<span class="sd">        kernel : str, optional</span>
<span class="sd">            kernel function to use in order to weight the output graph. See</span>
<span class="sd">            :meth:`Graph.build_kernel` for details. By default &quot;boxcar&quot;</span>
<span class="sd">        clip : str (default: &#39;bbox&#39;)</span>
<span class="sd">            Clipping method when ``method=&quot;voronoi&quot;``. Ignored otherwise.</span>
<span class="sd">            Default is ``&#39;bounding_box&#39;``. Options are as follows.</span>

<span class="sd">            ``None``</span>
<span class="sd">                No clip is applied. Voronoi cells may be arbitrarily larger that the</span>
<span class="sd">                source map. Note that this may lead to cells that are many orders of</span>
<span class="sd">                magnitude larger in extent than the original map. Not recommended.</span>
<span class="sd">            ``&#39;bounding_box&#39;``</span>
<span class="sd">                Clip the voronoi cells to the bounding box of the input points.</span>
<span class="sd">            ``&#39;convex_hull&#39;``</span>
<span class="sd">                Clip the voronoi cells to the convex hull of the input points.</span>
<span class="sd">            ``&#39;alpha_shape&#39;``</span>
<span class="sd">                Clip the voronoi cells to the tightest hull that contains all points</span>
<span class="sd">                (e.g. the smallest alpha shape, using</span>
<span class="sd">                :func:`libpysal.cg.alpha_shape_auto`).</span>
<span class="sd">            ``shapely.Polygon``</span>
<span class="sd">                Clip to an arbitrary Polygon.</span>

<span class="sd">        rook : bool, optional</span>
<span class="sd">            Contiguity method when ``method=&quot;voronoi&quot;``. Ignored otherwise.</span>
<span class="sd">            If True, two geometries are considered neighbours if they</span>
<span class="sd">            share at least one edge. If False, two geometries are considered neighbours</span>
<span class="sd">            if they share at least one vertex. By default True</span>
<span class="sd">        coplanar: str, optional (default &quot;raise&quot;)</span>
<span class="sd">            Method for handling coplanar points. Options include</span>
<span class="sd">            ``&#39;raise&#39;`` (raising an exception when coplanar points are present),</span>
<span class="sd">            ``&#39;jitter&#39;`` (randomly displace coplanar points to produce uniqueness), &amp;</span>
<span class="sd">            ``&#39;clique&#39;`` (induce fully-connected sub cliques for coplanar points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            libpysal.graph.Graph encoding triangulation weights</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        Note that the method requires point geometry (or an array of coordinates</span>
<span class="sd">        representing points) as an input.</span>

<span class="sd">        &gt;&gt;&gt; triangulation = graph.Graph.build_triangulation(nybb.centroid)</span>
<span class="sd">        &gt;&gt;&gt; triangulation.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Queens         Brooklyn         1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Brooklyn       Staten Island    1</span>
<span class="sd">                       Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Manhattan      Staten Island    1</span>
<span class="sd">                       Queens           1</span>
<span class="sd">                       Brooklyn         1</span>
<span class="sd">                       Bronx            1</span>
<span class="sd">        Bronx          Queens           1</span>
<span class="sd">                       Manhattan        1</span>
<span class="sd">        Name: weight, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">_evaluate_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;delaunay&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_delaunay</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gabriel&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_gabriel</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;relative_neighborhood&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_relative_neighborhood</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;voronoi&quot;</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_voronoi</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">,</span> <span class="n">rook</span><span class="o">=</span><span class="n">rook</span><span class="p">,</span> <span class="n">coplanar</span><span class="o">=</span><span class="n">coplanar</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not supported. Use one of [&#39;delaunay&#39;, &quot;</span>
                <span class="s2">&quot;&#39;gabriel&#39;, &#39;relative_neighborhood&#39;, &#39;voronoi&#39;].&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_h3">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_h3">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_h3</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Graph from indices of H3 hexagons.</span>

<span class="sd">        Encode a graph from a set of H3 hexagons. The graph is generated by</span>
<span class="sd">        considering the H3 hexagons as nodes and connecting them based on their</span>
<span class="sd">        contiguity. The contiguity is defined by the order parameter, which</span>
<span class="sd">        specifies the number of steps to consider as neighbors. The weight</span>
<span class="sd">        parameter defines the type of weight to assign to the edges.</span>

<span class="sd">        Requires the `h3` library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ids : array-like</span>
<span class="sd">            Array of H3 IDs encoding focal geometries</span>
<span class="sd">        order : int, optional</span>
<span class="sd">            Order of contiguity, by default 1</span>
<span class="sd">        weight : str, optional</span>
<span class="sd">            Type of weight. Options are:</span>

<span class="sd">            * ``distance``: raw topological distance between cells</span>
<span class="sd">            * ``binary``: 1 for neighbors, 0 for non-neighbors</span>
<span class="sd">            * ``inverse``: 1 / distance between cells</span>

<span class="sd">            By default &quot;distance&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; from tobler.util import h3fy</span>
<span class="sd">        &gt;&gt;&gt; gdf = gpd.read_file(get_path(&quot;geoda guerry&quot;))</span>
<span class="sd">        &gt;&gt;&gt; h3 = h3fy(gdf, resolution=4)</span>
<span class="sd">        &gt;&gt;&gt; h3.head()</span>
<span class="sd">                                                                  geometry</span>
<span class="sd">        hex_id</span>
<span class="sd">        841f94dffffffff  POLYGON ((609346.657 2195981.397, 604556.817 2...</span>
<span class="sd">        841fa67ffffffff  POLYGON ((722074.162 2561038.244, 717442.706 2...</span>
<span class="sd">        84186a3ffffffff  POLYGON ((353695.287 2121176.341, 329999.974 2...</span>
<span class="sd">        8418609ffffffff  POLYGON ((387747.482 2509794.492, 364375.032 2...</span>
<span class="sd">        8418491ffffffff  POLYGON ((320872.289 1846157.662, 296923.464 1...</span>

<span class="sd">        &gt;&gt;&gt; h3_contiguity = graph.Graph.build_h3(h3.index)</span>
<span class="sd">        &gt;&gt;&gt; h3_contiguity</span>
<span class="sd">        &lt;Graph of 320 nodes and 1740 nonzero edges indexed by</span>
<span class="sd">         [&#39;841f94dffffffff&#39;, &#39;841fa67ffffffff&#39;, &#39;84186a3ffffffff&#39;, ...]&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_build_from_h3</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span>
        <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;binary&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;inverse&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">_adjacency</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight must be one of &#39;distance&#39;, &#39;binary&#39;, or &#39;inverse&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.build_travel_cost">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.build_travel_cost">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_travel_cost</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapping_distance</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a Graph based on shortest travel costs from a pandana.Network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : geopandas.GeoDataFrame</span>
<span class="sd">            geodataframe representing observations which are snapped to the nearest</span>
<span class="sd">            node in the pandana.Network. CRS should be the same as the locations</span>
<span class="sd">            of ``node_x`` and ``node_y`` in the pandana.Network (usually 4326 if network</span>
<span class="sd">            comes from OSM, but sometimes projected to improve snapping quality).</span>
<span class="sd">        network : pandana.Network</span>
<span class="sd">            pandana Network object describing travel costs between nodes in the study</span>
<span class="sd">            area.  See &lt;https://udst.github.io/pandana/&gt; for more</span>
<span class="sd">        threshold : int</span>
<span class="sd">            threshold representing maximum cost distances. This is measured in the same</span>
<span class="sd">            units as the pandana.Network (not influenced by the df.crs in any way). For</span>
<span class="sd">            travel modes with relatively constant speeds like walking or biking, this is</span>
<span class="sd">            usually distance (e.g. meters if the Network is constructed from OSM). For a</span>
<span class="sd">            a multimodal or auto network with variable travel speeds, this is usually</span>
<span class="sd">            some measure of travel time</span>
<span class="sd">        kernel : str or callable, optional</span>
<span class="sd">            kernel transformation applied to the weights. See</span>
<span class="sd">            libpysal.graph.Graph.build_kernel for more information on kernel</span>
<span class="sd">            transformation options. Default is None, in which case the Graph weight</span>
<span class="sd">            is pure distance between focal and neighbor</span>
<span class="sd">        mapping_distance : int</span>
<span class="sd">            snapping tolerance passed to ``pandana.Network.get_node_ids`` that defines</span>
<span class="sd">            the maximum range at which observations are snapped to nearest nodes in the</span>
<span class="sd">            network. Default is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; import geodatasets</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; import osmnx as ox</span>
<span class="sd">        &gt;&gt;&gt; import pandana as pdna</span>

<span class="sd">        Read an example geodataframe:</span>

<span class="sd">        &gt;&gt;&gt; df = gpd.read_file(geodatasets.get_path(&quot;geoda Cincinnati&quot;)).to_crs(4326)</span>

<span class="sd">        Download a walk network using osmnx</span>

<span class="sd">        &gt;&gt;&gt; osm_graph = ox.graph_from_polygon(df.union_all(), network_type=&quot;walk&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nodes, edges = ox.utils_graph.graph_to_gdfs(osm_graph)</span>
<span class="sd">        &gt;&gt;&gt; edges = edges.reset_index()</span>

<span class="sd">        Generate a routable pandana network from the OSM nodes and edges</span>

<span class="sd">        &gt;&gt;&gt; network = pdna.Network(</span>
<span class="sd">        &gt;&gt;&gt;     edge_from=edges[&quot;u&quot;],</span>
<span class="sd">        &gt;&gt;&gt;     edge_to=edges[&quot;v&quot;],</span>
<span class="sd">        &gt;&gt;&gt;     edge_weights=edges[[&quot;length&quot;]],</span>
<span class="sd">        &gt;&gt;&gt;     node_x=nodes[&quot;x&quot;],</span>
<span class="sd">        &gt;&gt;&gt;     node_y=nodes[&quot;y&quot;],)</span>

<span class="sd">        Use the pandana network to compute shortest paths between gdf centroids and</span>
<span class="sd">        generate a Graph</span>

<span class="sd">        &gt;&gt;&gt; G = Graph.build_travel_cost(df.set_geometry(df.centroid), network, 500)</span>
<span class="sd">        &gt;&gt;&gt; G.adjacency.head()</span>
<span class="sd">        focal  neighbor</span>
<span class="sd">        0       62          385.609009</span>
<span class="sd">                65          309.471985</span>
<span class="sd">                115         346.858002</span>
<span class="sd">                116           0.000000</span>
<span class="sd">                117         333.639008</span>
<span class="sd">        Name: weight, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">_build_travel_graph</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">mapping_distance</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="n">_kernel</span><span class="p">(</span>
                <span class="n">g</span><span class="o">.</span><span class="n">sparse</span><span class="p">,</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;precomputed&quot;</span><span class="p">,</span>
                <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                <span class="n">bandwidth</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                <span class="n">resolve_isolates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get neighbors dictionary</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is recommended to work directly with :meth:`Graph.adjacency` rather than</span>
<span class="sd">        using the :meth:`Graph.neighbors`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dict of tuples representing neighbors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">grouper</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">neighbors</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get weights dictionary</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is recommended to work directly with :meth:`Graph.adjacency` rather than</span>
<span class="sd">        using the :meth:`Graph.weights`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dict of tuples representing weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">grouper</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weights</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a scipy.sparse array (CSR)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.sparse.CSR</span>
<span class="sd">            sparse representation of the adjacency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pivot to COO sparse matrix and cast to sparse CRS array</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;Sparse[float]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">to_coo</span><span class="p">(</span><span class="n">sort_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Graph.transform">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transformation of weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transformation : str | callable</span>
<span class="sd">            Transformation method. The following are</span>
<span class="sd">            valid transformations.</span>

<span class="sd">            - **B** -- Binary</span>
<span class="sd">            - **R** -- Row-standardization (global sum :math:`=n`)</span>
<span class="sd">            - **D** -- Double-standardization (global sum :math:`=1`)</span>
<span class="sd">            - **V** -- Variance stabilizing</span>

<span class="sd">            Alternatively, you can pass your own callable passed to</span>
<span class="sd">            ``self.adjacency.groupby(level=0).transform()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            transformed weights</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Value error for unsupported transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">==</span> <span class="n">transformation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>  <span class="c1"># isolate comes as NaN -&gt; 0</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">values</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">transformation</span> <span class="o">==</span> <span class="s2">&quot;V&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">group</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">n_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">n_q</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># isolate comes as NaN -&gt; 0</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">transformation</span><span class="p">):</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="n">transformation</span>
            <span class="p">)</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Transformation &#39;</span><span class="si">{</span><span class="n">transformation</span><span class="si">}</span><span class="s2">&#39; is not supported. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use one of </span><span class="si">{</span><span class="n">ALLOWED_TRANSFORMATIONS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2"> or pass a callable.&quot;</span>
            <span class="p">)</span>

        <span class="n">standardized_adjacency</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">standardized</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>
        <span class="n">transformed</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">standardized_adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xarray_index_names&quot;</span><span class="p">):</span>
            <span class="n">transformed</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray_index_names</span>
        <span class="k">return</span> <span class="n">transformed</span></div>


    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper for n_components and component_labels&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number of connected components</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">component_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get component labels per observation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.array</span>
<span class="sd">            Array of component labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;component labels&quot;</span>
        <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cardinalities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of neighbors for each observation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            Series with a number of neighbors per each observation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">cardinalities</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;cardinalities&quot;</span>
        <span class="k">return</span> <span class="n">cardinalities</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isolates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index of observations with no neighbors</span>

<span class="sd">        Isolates are encoded as a self-loop with</span>
<span class="sd">        the weight == 0 in the adjacency table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Index</span>
<span class="sd">            Index with a subset of observations that do not have any neighbor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinalities</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cardinalities</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique IDs used in the Graph&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of observations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pct_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Percentage of nonzero weights.&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">nnz</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of nonzero weights.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">index_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return focal-neighbor index pairs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(Index, Index)</span>
<span class="sd">            tuple of two aligned pandas.Index objects encoding all edges of the Graph</span>
<span class="sd">            by their nodes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; focal, neighbor = contiguity.index_pairs</span>
<span class="sd">        &gt;&gt;&gt; focal</span>
<span class="sd">        Index([&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Queens&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Brooklyn&#39;,</span>
<span class="sd">               &#39;Manhattan&#39;, &#39;Manhattan&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;, &#39;Bronx&#39;],</span>
<span class="sd">              dtype=&#39;object&#39;, name=&#39;focal&#39;)</span>

<span class="sd">        &gt;&gt;&gt; neighbor</span>
<span class="sd">        Index([&#39;Staten Island&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;, &#39;Queens&#39;,</span>
<span class="sd">               &#39;Manhattan&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Bronx&#39;, &#39;Queens&#39;, &#39;Manhattan&#39;],</span>
<span class="sd">              dtype=&#39;object&#39;, name=&#39;neighbor&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">focal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span>
        <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.asymmetry">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.asymmetry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asymmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Asymmetry check.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        intrinsic : bool, optional</span>
<span class="sd">            Default is ``True``. Intrinsic symmetry is defined as:</span>

<span class="sd">            .. math::</span>

<span class="sd">                w_{i,j} == w_{j,i}</span>

<span class="sd">            If ``intrinsic`` is ``False`` symmetry is defined as:</span>

<span class="sd">            .. math::</span>

<span class="sd">                i \in N_j \ \&amp; \ j \in N_i</span>

<span class="sd">            where :math:`N_j` is the set of neighbors for :math:`j`,</span>
<span class="sd">            e.g., ``True`` requires equality of the weight to consider</span>
<span class="sd">            two links equal, ``False`` requires only a presence of a link</span>
<span class="sd">            with a non-zero weight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            A ``Series`` of ``(i,j)`` pairs of asymmetries sorted</span>
<span class="sd">            ascending by the focal observation (index value),</span>
<span class="sd">            where ``i`` is the focal and ``j`` is the neighbor.</span>
<span class="sd">            An empty ``Series`` is returned if no asymmetries are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intrinsic</span><span class="p">:</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
            <span class="n">wd</span> <span class="o">=</span> <span class="n">transformed</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="n">transformed</span><span class="o">.</span><span class="n">sparse</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i2id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">focal</span><span class="p">,</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
            <span class="n">focal</span> <span class="o">=</span> <span class="n">focal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">])</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i2id</span><span class="p">:</span>
                <span class="n">focal</span><span class="p">[</span><span class="n">focal</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">neighbor</span><span class="p">[</span><span class="n">neighbor</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ijs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">neighbor</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ijs</span></div>


<div class="viewcode-block" id="Graph.summary">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asymmetries</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summary of the Graph properties</span>

<span class="sd">        Returns a :class:`GraphSummary` object with the statistical attributes</span>
<span class="sd">        summarising the Graph and its basic properties. See the docstring of the</span>
<span class="sd">        :class:`GraphSummary` for details and all the available attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asymmetries : bool</span>
<span class="sd">            whether to compute ``n_asymmetries``, which is considerably more expensive</span>
<span class="sd">            than the other attributes. By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GraphSummary</span>
<span class="sd">            a class containing a summary statisitcs about the graph</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity</span>
<span class="sd">        &lt;Graph of 5 nodes and 10 nonzero edges indexed by</span>
<span class="sd">         [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>

<span class="sd">        &gt;&gt;&gt; summary = contiguity.summary(asymmetries=True)</span>
<span class="sd">        &gt;&gt;&gt; summary</span>
<span class="sd">        Graph Summary Statistics</span>
<span class="sd">        ========================</span>
<span class="sd">        Graph indexed by:</span>
<span class="sd">        [&#39;Staten Island&#39;, &#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]</span>
<span class="sd">        ==============================================================</span>
<span class="sd">        Number of nodes:                                             5</span>
<span class="sd">        Number of edges:                                            10</span>
<span class="sd">        Number of connected components:                              2</span>
<span class="sd">        Number of isolates:                                          1</span>
<span class="sd">        Number of non-zero edges:                                   10</span>
<span class="sd">        Percentage of non-zero edges:                           44.00%</span>
<span class="sd">        Number of asymmetries:                                       0</span>
<span class="sd">        --------------------------------------------------------------</span>
<span class="sd">        Cardinalities</span>
<span class="sd">        ==============================================================</span>
<span class="sd">        Mean:                       2    25%:                        2</span>
<span class="sd">        Standard deviation:         1    50%:                        2</span>
<span class="sd">        Min:                        0    75%:                        3</span>
<span class="sd">        Max:                        3</span>
<span class="sd">        --------------------------------------------------------------</span>
<span class="sd">        Weights</span>
<span class="sd">        ==============================================================</span>
<span class="sd">        Mean:                       1    25%:                        1</span>
<span class="sd">        Standard deviation:         0    50%:                        1</span>
<span class="sd">        Min:                        0    75%:                        1</span>
<span class="sd">        Max:                        1</span>
<span class="sd">        --------------------------------------------------------------</span>
<span class="sd">        Sum of weights</span>
<span class="sd">        ==============================================================</span>
<span class="sd">        S0:                                                         10</span>
<span class="sd">        S1:                                                         20</span>
<span class="sd">        S2:                                                        104</span>
<span class="sd">        --------------------------------------------------------------</span>
<span class="sd">        Traces</span>
<span class="sd">        ==============================================================</span>
<span class="sd">        GG:                                                         10</span>
<span class="sd">        G&#39;G:                                                        10</span>
<span class="sd">        G&#39;G + GG:                                                   20</span>

<span class="sd">        &gt;&gt;&gt; summary.s1</span>
<span class="sd">        20</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GraphSummary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asymmetries</span><span class="o">=</span><span class="n">asymmetries</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.higher_order">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.higher_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">higher_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shortest_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower_order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contiguity weights object of order :math:`k`.</span>

<span class="sd">        Proper higher order neighbors are returned such that :math:`i` and :math:`j`</span>
<span class="sd">        are :math:`k`-order neighbors if the shortest path from :math:`i-j` is of</span>
<span class="sd">        length :math:`k`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Order of contiguity. By default 2.</span>
<span class="sd">        shortest_path : bool, optional</span>
<span class="sd">            If True, :math:`i,j` and :math:`k`-order neighbors if the shortest</span>
<span class="sd">            path for :math:`i,j` is :math:`k`. If False, :math:`i,j` are</span>
<span class="sd">            `k`-order neighbors if there is a path from :math:`i,j` of length</span>
<span class="sd">            :math:`k`. By default True.</span>
<span class="sd">        diagonal : bool, optional</span>
<span class="sd">            If True, keep :math:`k`-order (:math:`i,j`) joins when :math:`i==j`.</span>
<span class="sd">            If False, remove :math:`k`-order (:math:`i,j`) joins when</span>
<span class="sd">            :math:`i==j`. By default False.</span>
<span class="sd">        lower_order : bool, optional</span>
<span class="sd">            If True, include lower order contiguities. If False return only weights of</span>
<span class="sd">            order :math:`k`. By default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            higher order weights</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; gdf = gpd.read_file(get_path(&quot;geoda guerry&quot;))</span>
<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(gdf)</span>
<span class="sd">        &gt;&gt;&gt; contiguity</span>
<span class="sd">        &lt;Graph of 85 nodes and 420 nonzero edges indexed by</span>
<span class="sd">         [0, 1, 2, 3, 4, ...]&gt;</span>

<span class="sd">        &gt;&gt;&gt; contiguity.higher_order(k=2)</span>
<span class="sd">        &lt;Graph of 85 nodes and 756 nonzero edges indexed by</span>
<span class="sd">         [0, 1, 2, 3, 4, ...]&gt;</span>

<span class="sd">        &gt;&gt;&gt; contiguity.higher_order(lower_order=True)</span>
<span class="sd">        &lt;Graph of 85 nodes and 1176 nonzero edges indexed by</span>
<span class="sd">         [0, 1, 2, 3, 4, ...]&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Version</span><span class="p">(</span><span class="n">scipy_version</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">&quot;1.12.0&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Graph.higher_order() requires scipy&gt;=1.12.0.&quot;</span><span class="p">)</span>

        <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">sparse</span>

        <span class="k">if</span> <span class="n">lower_order</span><span class="p">:</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">shortest_path</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wk</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">rk</span><span class="p">,</span> <span class="n">ck</span> <span class="o">=</span> <span class="n">wk</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rk</span><span class="p">,</span> <span class="n">ck</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">shortest_path</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">wj</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">rj</span><span class="p">,</span> <span class="n">cj</span> <span class="o">=</span> <span class="n">wj</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="n">sj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rj</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">sk</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diagonal</span><span class="p">:</span>
            <span class="n">sk</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sk</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">}</span>

        <span class="n">higher</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_sparse</span><span class="p">(</span>
            <span class="n">sparse</span><span class="o">.</span><span class="n">coo_array</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
                    <span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sk</span><span class="p">],</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sk</span><span class="p">]),</span>
                <span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">ids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xarray_index_names&quot;</span><span class="p">):</span>
            <span class="n">higher</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray_index_names</span>

        <span class="k">return</span> <span class="n">higher</span></div>


<div class="viewcode-block" id="Graph.lag">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.lag">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ties</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial lag operator</span>

<span class="sd">        Constructs spatial lag based on neighbor relations of the graph.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array</span>
<span class="sd">            numpy array with dimensionality conforming to w</span>
<span class="sd">        categorical : bool</span>
<span class="sd">            True if y is categorical, False if y is continuous.</span>
<span class="sd">        ties : {&#39;raise&#39;, &#39;random&#39;, &#39;tryself&#39;}, optional</span>
<span class="sd">            Policy on how to break ties when a focal unit has multiple</span>
<span class="sd">            modes for a categorical lag.</span>
<span class="sd">            - &#39;raise&#39;: This will raise an exception if ties are</span>
<span class="sd">            encountered to alert the user (Default).</span>
<span class="sd">            - &#39;random&#39;: modal label ties Will be broken randomly.</span>
<span class="sd">            - &#39;tryself&#39;: check if focal label breaks the tie between label</span>
<span class="sd">            modes.  If the focal label does not break the modal tie, the</span>
<span class="sd">            tie will be be broken randomly. If the focal unit has a</span>
<span class="sd">            self-weight, focal label is not used to break any tie,</span>
<span class="sd">            rather any tie will be broken randomly.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of numeric|categorical values for the spatial lag</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; aus = gpd.read_file(get_path(&quot;abs.australia_states_territories&quot;)).set_index(</span>
<span class="sd">        ...     &quot;STE_NAME21&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; aus = aus[aus.geometry.notna()]</span>
<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(aus)</span>

<span class="sd">        Spatial lag operator for continuous variables.</span>

<span class="sd">        &gt;&gt;&gt; y = np.arange(9)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.lag(y)</span>
<span class="sd">        array([21.,  3.,  9., 13.,  9.,  0.,  9.,  0.,  0.])</span>

<span class="sd">        You can also perform transformation of weights.</span>

<span class="sd">        &gt;&gt;&gt; contiguity_r = contiguity.transform(&quot;r&quot;)</span>
<span class="sd">        &gt;&gt;&gt; contiguity_r.lag(y)</span>
<span class="sd">        array([4.2, 1.5, 3. , 2.6, 4.5, 0. , 3. , 0. , 0. ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_lag_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">categorical</span><span class="o">=</span><span class="n">categorical</span><span class="p">,</span> <span class="n">ties</span><span class="o">=</span><span class="n">ties</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_parquet">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_parquet">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save Graph to a Apache Parquet</span>

<span class="sd">        Graph is serialized to the Apache Parquet using the underlying adjacency</span>
<span class="sd">        object stored as a Parquet table and custom metadata containing transformation.</span>

<span class="sd">        Requires pyarrow package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str | pyarrow.NativeFile</span>
<span class="sd">            path or any stream supported by pyarrow</span>
<span class="sd">        **kwargs</span>
<span class="sd">            additional keyword arguments passed to pyarrow.parquet.write_table</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        read_parquet</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.to_parquet(&quot;contiguity.parquet&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_to_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_gal">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_gal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_gal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save Graph to a GAL file</span>

<span class="sd">        Graph is serialized to the GAL file format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            path to the GAL file</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        read_gal</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.to_gal(&quot;contiguity.gal&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_to_gal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_gwt">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_gwt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_gwt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save Graph to a GWT file</span>

<span class="sd">        Graph is serialized to the GWT file format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            path to the GWT file</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        read_gwt</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb).transform(&quot;r&quot;)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.to_gwt(&quot;contiguity.gwt&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_to_gwt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.to_networkx">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.to_networkx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Graph to a ``networkx`` graph.</span>

<span class="sd">        If Graph is symmetric, returns ``nx.Graph``, otherwise returns a ``nx.DiGraph``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.Graph | networkx.DiGraph</span>
<span class="sd">            Representation of libpysal Graph as networkx graph</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; nx_graph = contiguity.to_networkx()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;NetworkX is required.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

        <span class="n">graph_type</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asymmetry</span><span class="p">()</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span>

        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
            <span class="n">source</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
            <span class="n">edge_attr</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="n">create_using</span><span class="o">=</span><span class="n">graph_type</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.plot">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">focal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">edge_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_extent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot edges and nodes of the Graph</span>

<span class="sd">        Creates a ``maptlotlib`` plot based on the topology stored in the</span>
<span class="sd">        Graph and spatial location defined in ``gdf``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf : geopandas.GeoDataFrame</span>
<span class="sd">            Geometries indexed using the same index as Graph. Geometry types other than</span>
<span class="sd">            points are converted to centroids encoding start and end point of Graph</span>
<span class="sd">            edges.</span>
<span class="sd">        focal : hashable | array-like[hashable] | None, optional</span>
<span class="sd">            ID or an array-like of IDs of focal geometries whose weights shall be</span>
<span class="sd">            plotted. If None, all weights from all focal geometries are plotted.</span>
<span class="sd">            By default None</span>
<span class="sd">        nodes : bool, optional</span>
<span class="sd">            Plot nodes as points, by default True</span>
<span class="sd">        color : str, optional</span>
<span class="sd">            The color of all objects, by default &quot;k&quot;</span>
<span class="sd">        edge_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``LineCollection``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the edges in the plot. By default None</span>
<span class="sd">        node_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``ax.scatter``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the nodes in the plot. By default None</span>
<span class="sd">        focal_kws : dict, optional</span>
<span class="sd">            Keyword arguments dictionary to send to ``ax.scatter``,</span>
<span class="sd">            which provides fine-grained control over the aesthetics</span>
<span class="sd">            of the focal nodes in the plot on top of generic ``node_kws``.</span>
<span class="sd">            Values of ``node_kws`` are updated from ``focal_kws``.</span>
<span class="sd">            Ignored if ``focal=None``. By default None</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axis on which to plot the weights. If None, a new figure and axis are</span>
<span class="sd">            created. By default None</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            figsize used to create a new axis. By default None</span>
<span class="sd">        limit_extent : bool, optional</span>
<span class="sd">            limit the extent of the axis to the extent of the plotted graph, by default</span>
<span class="sd">            False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes.Axes</span>
<span class="sd">            Axis with the resulting plot</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you&#39;d like to overlay the actual geometries from the</span>
<span class="sd">        ``geopandas.GeoDataFrame``, create an axis by plotting the ``GeoDataFrame``</span>
<span class="sd">        and plot the Graph on top.</span>

<span class="sd">            ax = gdf.plot()</span>
<span class="sd">            gdf_graph.plot(gdf, ax=ax)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">gdf</span><span class="p">,</span>
            <span class="n">focal</span><span class="o">=</span><span class="n">focal</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">node_kws</span><span class="o">=</span><span class="n">node_kws</span><span class="p">,</span>
            <span class="n">edge_kws</span><span class="o">=</span><span class="n">edge_kws</span><span class="p">,</span>
            <span class="n">focal_kws</span><span class="o">=</span><span class="n">focal_kws</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
            <span class="n">limit_extent</span><span class="o">=</span><span class="n">limit_extent</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.explore">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.explore">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">explore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gdf</span><span class="p">,</span>
        <span class="n">focal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">edge_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">focal_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot graph as an interactive Folium Map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf : geopandas.GeoDataFrame</span>
<span class="sd">            geodataframe used to instantiate to Graph</span>
<span class="sd">        focal : list, optional</span>
<span class="sd">            subset of focal observations to plot in the map, by default None.</span>
<span class="sd">            If none, all relationships are plotted</span>
<span class="sd">        nodes : bool, optional</span>
<span class="sd">            whether to display observations as nodes in the map, by default True</span>
<span class="sd">        color : str, optional</span>
<span class="sd">            color applied to nodes and edges, by default &quot;black&quot;</span>
<span class="sd">        edge_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting edges, by default None</span>
<span class="sd">        node_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting nodes, by default None</span>
<span class="sd">        focal_kws : dict, optional</span>
<span class="sd">            additional keyword arguments passed to geopandas explore function</span>
<span class="sd">            when plotting focal observations, by default None. Only applicable when</span>
<span class="sd">            passing a subset of nodes with the `focal` argument</span>
<span class="sd">        m : Folilum.Map, optional</span>
<span class="sd">            folium map objecto to plot on top of, by default None</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            additional keyword arguments are passed directly to geopandas.explore, when</span>
<span class="sd">            ``m=None`` by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            folium map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_explore_graph</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">gdf</span><span class="p">,</span>
            <span class="n">focal</span><span class="o">=</span><span class="n">focal</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">edge_kws</span><span class="o">=</span><span class="n">edge_kws</span><span class="p">,</span>
            <span class="n">node_kws</span><span class="o">=</span><span class="n">node_kws</span><span class="p">,</span>
            <span class="n">focal_kws</span><span class="o">=</span><span class="n">focal_kws</span><span class="p">,</span>
            <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Graph.subgraph">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.subgraph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a subset of Graph containing only nodes specified in ids</span>

<span class="sd">        The resulting subgraph contains only the nodes in ``ids`` and the edges</span>
<span class="sd">        between them or zero-weight self-loops in case of isolates.</span>

<span class="sd">        The order of ``ids`` reflects a new canonical order of the resulting</span>
<span class="sd">        subgraph. This means ``ids`` should be equal to the index of the DataFrame</span>
<span class="sd">        containing data linked to the graph to ensure alignment of sparse representation</span>
<span class="sd">        of subgraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ids : array-like</span>
<span class="sd">            An array of node IDs to be retained</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            A new Graph that is a subset of the original</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity.subgraph([&quot;Queens&quot;, &quot;Brooklyn&quot;, &quot;Manhattan&quot;, &quot;Bronx&quot;])</span>
<span class="sd">        &lt;Graph of 4 nodes and 10 nonzero edges indexed by</span>
<span class="sd">         [&#39;Queens&#39;, &#39;Brooklyn&#39;, &#39;Manhattan&#39;, &#39;Bronx&#39;]&gt;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike the implementation in ``networkx``, this creates a copy since</span>
<span class="sd">        Graphs in ``libpysal`` are immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masked_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ids</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">filtered_adj</span> <span class="o">=</span> <span class="n">masked_adj</span><span class="p">[</span>
            <span class="n">masked_adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
            <span class="o">*</span><span class="n">_resolve_islands</span><span class="p">(</span>
                <span class="n">filtered_adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">),</span>
                <span class="n">filtered_adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">),</span>
                <span class="n">ids</span><span class="p">,</span>
                <span class="n">filtered_adj</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xarray_index_names&quot;</span><span class="p">):</span>
            <span class="n">sub</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray_index_names</span>

        <span class="k">return</span> <span class="n">sub</span></div>


<div class="viewcode-block" id="Graph.eliminate_zeros">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.eliminate_zeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eliminate_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove graph edges with zero weight</span>

<span class="sd">        Eliminates edges with weight == 0 that do not encode an</span>
<span class="sd">        isolate. This is useful to clean-up edges that will make</span>
<span class="sd">        no effect in operations like :meth:`lag`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            subset of Graph with zero-weight edges eliminated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># substract isolates from mask of zeros</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">isolates</span>
        <span class="p">)</span>

        <span class="n">eliminated</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="p">[</span><span class="o">~</span><span class="n">zeros</span><span class="p">],</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xarray_index_names&quot;</span><span class="p">):</span>
            <span class="n">eliminated</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray_index_names</span>

        <span class="k">return</span> <span class="n">eliminated</span></div>


<div class="viewcode-block" id="Graph.assign_self_weight">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.assign_self_weight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assign_self_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign values to edges representing self-weight.</span>

<span class="sd">        The value for each ``focal == neighbor`` location in</span>
<span class="sd">        the graph is set to ``weight``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : float | array-like</span>
<span class="sd">            Defines the value(s) to which the weight representing the relationship with</span>
<span class="sd">            itself should be set. If a constant is passed then each self-weight will get</span>
<span class="sd">            this value (default is 1). An array of length ``Graph.n`` can be passed to</span>
<span class="sd">            set explicit values to each self-weight (assumed to be in the same order as</span>
<span class="sd">            original data).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Graph</span>
<span class="sd">            A new ``Graph`` with added self-weights.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from geodatasets import get_path</span>
<span class="sd">        &gt;&gt;&gt; nybb = gpd.read_file(get_path(&quot;nybb&quot;)).set_index(&quot;BoroName&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nybb</span>
<span class="sd">                       BoroCode  ...                                           geometry</span>
<span class="sd">        BoroName                 ...</span>
<span class="sd">        Staten Island         5  ...  MULTIPOLYGON (((970217.022 145643.332, 970227....</span>
<span class="sd">        Queens                4  ...  MULTIPOLYGON (((1029606.077 156073.814, 102957...</span>
<span class="sd">        Brooklyn              3  ...  MULTIPOLYGON (((1021176.479 151374.797, 102100...</span>
<span class="sd">        Manhattan             1  ...  MULTIPOLYGON (((981219.056 188655.316, 980940....</span>
<span class="sd">        Bronx                 2  ...  MULTIPOLYGON (((1012821.806 229228.265, 101278...</span>
<span class="sd">        [5 rows x 4 columns]</span>

<span class="sd">        &gt;&gt;&gt; contiguity = graph.Graph.build_contiguity(nybb)</span>
<span class="sd">        &gt;&gt;&gt; contiguity_weights = contiguity.assign_self_weight(0.5)</span>
<span class="sd">        &gt;&gt;&gt; contiguity_weights.adjacency</span>
<span class="sd">        focal          neighbor</span>
<span class="sd">        Staten Island  Staten Island    0.5</span>
<span class="sd">        Queens         Queens           0.5</span>
<span class="sd">                       Brooklyn         1.0</span>
<span class="sd">                       Manhattan        1.0</span>
<span class="sd">                       Bronx            1.0</span>
<span class="sd">        Brooklyn       Queens           1.0</span>
<span class="sd">                       Brooklyn         0.5</span>
<span class="sd">                       Manhattan        1.0</span>
<span class="sd">        Manhattan      Queens           1.0</span>
<span class="sd">                       Brooklyn         1.0</span>
<span class="sd">                       Manhattan        0.5</span>
<span class="sd">                       Bronx            1.0</span>
<span class="sd">        Bronx          Queens           1.0</span>
<span class="sd">                       Manhattan        1.0</span>
<span class="sd">                       Bronx            0.5</span>
<span class="sd">        Name: weight, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">addition</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">weight</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># drop existing self weights and replace them with a new value</span>
        <span class="n">existing_self_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">existing_self_weights</span><span class="p">),</span> <span class="n">addition</span><span class="p">])</span>
            <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">assigned</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xarray_index_names&quot;</span><span class="p">):</span>
            <span class="n">assigned</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xarray_index_names</span>

        <span class="k">return</span> <span class="n">assigned</span></div>


<div class="viewcode-block" id="Graph.apply">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.apply">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a reduction across the neighbor sets</span>

<span class="sd">        Applies ``func`` over groups of ``y`` defined by neighbors for each focal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array_like</span>
<span class="sd">            array of values to be grouped. Can be 1-D or 2-D and will be coerced to a</span>
<span class="sd">            pandas object</span>
<span class="sd">        func : function, str, list, dict or None</span>
<span class="sd">            Function to use for aggregating the data passed to pandas ``GroupBy.apply``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series | DataFrame</span>
<span class="sd">            pandas object indexed by unique_ids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Graph.aggregate">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.aggregate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aggregate weights within a neighbor set</span>

<span class="sd">        Apply a custom aggregation function to a group of weights of the same focal</span>
<span class="sd">        geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            A callable accepted by pandas ``groupby.agg`` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Series</span>
<span class="sd">            Aggregated weights</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>


<div class="viewcode-block" id="Graph.describe">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.describe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">describe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">statistics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Describe the distribution of ``y`` values within the neighbors of each node.</span>

<span class="sd">        Given the graph, computes the descriptive statistics of values within the</span>
<span class="sd">        neighbourhood of each node. Optionally, the values can be limited to a certain</span>
<span class="sd">        quantile range before computing the statistics.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The index of ``values`` must match the index of the graph.</span>

<span class="sd">        Weight values do not affect the calculations, only adjacency does.</span>

<span class="sd">        Returns numpy.nan for all isolates.</span>

<span class="sd">        The numba package is used extensively in this function</span>
<span class="sd">        to accelerate the computation of statistics.</span>
<span class="sd">        Without numba, these computations may become slow on large data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : NDArray[np.float64] | Series</span>
<span class="sd">            An 1D array of numeric values to be described.</span>
<span class="sd">        q : tuple[float, float] | None, optional</span>
<span class="sd">            Tuple of percentages for the percentiles to compute.</span>
<span class="sd">            Values must be between 0 and 100 inclusive. When set, values below and above</span>
<span class="sd">            the percentiles will be discarded before computation of the statistics.</span>
<span class="sd">            The percentiles are computed for each neighborhood. By default None.</span>
<span class="sd">        statistics : list[str] | None</span>
<span class="sd">            A list of stats functions to compute. If None, compute all</span>
<span class="sd">            available functions - &quot;count&quot;, &quot;mean&quot;, &quot;median&quot;,</span>
<span class="sd">            &quot;std&quot;, &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;nunique&quot;, &quot;mode&quot;. By default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A DataFrame with descriptive statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The values index is not aligned with the graph index.&quot;</span><span class="p">)</span>

        <span class="c1"># reset numerical index to enable numba functionality</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="n">_percentile_filtration_grouper</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjacency</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

        <span class="n">stat_</span> <span class="o">=</span> <span class="n">_compute_stats</span><span class="p">(</span><span class="n">grouper</span><span class="p">,</span> <span class="n">statistics</span><span class="p">)</span>

        <span class="n">stat_</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_ids</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat_</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">stat_</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># NA isolates</span>
        <span class="n">stat_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">isolates</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">stat_</span></div>


<div class="viewcode-block" id="Graph.generate_da">
<a class="viewcode-back" href="../../../generated/libpysal.graph.Graph.html#libpysal.graph.Graph.generate_da">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_da</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates xarray.DataArray object from passed data aligned with the Graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array_like</span>
<span class="sd">            flat array that shall be reshaped into a DataArray with dimensionality</span>
<span class="sd">            conforming to Graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            instance of xarray.DataArray that can be aligned with the DataArray from</span>
<span class="sd">            which Graph was built</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_generate_da</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_arrange_arrays</span><span class="p">(</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rearrange input arrays so that observation indices</span>
<span class="sd">    are well-ordered with respect to the input ids. That is,</span>
<span class="sd">    an &quot;early&quot; identifier should always preceed a &quot;later&quot; identifier</span>
<span class="sd">    in the heads, but the tails should be sorted with respect</span>
<span class="sd">    to heads *first*, then sorted within the tails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">heads</span><span class="p">,</span> <span class="n">tails</span><span class="p">)))</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="n">heads</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="n">tails</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weights</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">input_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="n">focal_loc</span><span class="o">=</span><span class="n">input_df</span><span class="o">.</span><span class="n">focal</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">neighbor_loc</span><span class="o">=</span><span class="n">input_df</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;focal_loc&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_loc&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;focal_loc&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor_loc&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>


<div class="viewcode-block" id="read_parquet">
<a class="viewcode-back" href="../../../generated/libpysal.graph.read_parquet.html#libpysal.graph.read_parquet">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_parquet</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Graph from a Apache Parquet</span>

<span class="sd">    Read Graph serialized using `Graph.to_parquet()` back into the `Graph` object.</span>
<span class="sd">    The Parquet file needs to contain adjacency table with a structure required</span>
<span class="sd">    by the `Graph` constructor and optional metadata with the type of transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str | pyarrow.NativeFile | file-like object</span>
<span class="sd">        path or any stream supported by pyarrow</span>
<span class="sd">    **kwargs</span>
<span class="sd">        additional keyword arguments passed to pyarrow.parquet.read_table</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Graph</span>
<span class="sd">        deserialized Graph</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; graph.read_parquet(&quot;contiguity.parquet&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="p">,</span> <span class="n">xarray_index_names</span> <span class="o">=</span> <span class="n">_read_parquet</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">graph_obj</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">transformation</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xarray_index_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">graph_obj</span><span class="o">.</span><span class="n">_xarray_index_names</span> <span class="o">=</span> <span class="n">xarray_index_names</span>
    <span class="k">return</span> <span class="n">graph_obj</span></div>



<div class="viewcode-block" id="read_gal">
<a class="viewcode-back" href="../../../generated/libpysal.graph.read_gal.html#libpysal.graph.read_gal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_gal</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Graph from a GAL file</span>

<span class="sd">    The reader tries to infer the dtype of IDs. In case of unsuccessful</span>
<span class="sd">    casting to int, it will fall back to string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        path to a file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Graph</span>
<span class="sd">        deserialized Graph</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; graph.read_parquet(&quot;contiguity.gal&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">_read_gal</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_dicts</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span></div>



<div class="viewcode-block" id="read_gwt">
<a class="viewcode-back" href="../../../generated/libpysal.graph.read_gwt.html#libpysal.graph.read_gwt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_gwt</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read Graph from a GWT file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        path to a file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Graph</span>
<span class="sd">        deserialized Graph</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; graph.read_parquet(&quot;contiguity.gwt&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">_read_gwt</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>

</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>